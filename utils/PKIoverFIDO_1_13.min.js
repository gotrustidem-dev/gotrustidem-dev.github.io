var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.SIMPLE_FROUND_POLYFILL = !1;
$jscomp.ISOLATE_POLYFILLS = !1;
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, c, b) {
    if (a == Array.prototype || a == Object.prototype) return a;
    a[c] = b.value;
    return a
};
$jscomp.getGlobal = function (a) {
    a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
    for (var c = 0; c < a.length; ++c) {
        var b = a[c];
        if (b && b.Math == Math) return b
    }
    throw Error("Cannot find global object");
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE = "function" === typeof Symbol && "symbol" === typeof Symbol("x");
$jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
$jscomp.polyfills = {};
$jscomp.propertyToPolyfillSymbol = {};
$jscomp.POLYFILL_PREFIX = "$jscp$";
var $jscomp$lookupPolyfilledValue = function (a, c, b) {
    if (!b || null != a) {
        b = $jscomp.propertyToPolyfillSymbol[c];
        if (null == b) return a[c];
        b = a[b];
        return void 0 !== b ? b : a[c]
    }
};
$jscomp.polyfill = function (a, c, b, d) {
    c && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(a, c, b, d) : $jscomp.polyfillUnisolated(a, c, b, d))
};
$jscomp.polyfillUnisolated = function (a, c, b, d) {
    b = $jscomp.global;
    a = a.split(".");
    for (d = 0; d < a.length - 1; d++) {
        var f = a[d];
        if (!(f in b)) return;
        b = b[f]
    }
    a = a[a.length - 1];
    d = b[a];
    c = c(d);
    c != d && null != c && $jscomp.defineProperty(b, a, {
        configurable: !0,
        writable: !0,
        value: c
    })
};
$jscomp.polyfillIsolated = function (a, c, b, d) {
    var f = a.split(".");
    a = 1 === f.length;
    d = f[0];
    d = !a && d in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global;
    for (var e = 0; e < f.length - 1; e++) {
        var l = f[e];
        if (!(l in d)) return;
        d = d[l]
    }
    f = f[f.length - 1];
    b = $jscomp.IS_SYMBOL_NATIVE && "es6" === b ? d[f] : null;
    c = c(b);
    null != c && (a ? $jscomp.defineProperty($jscomp.polyfills, f, {
        configurable: !0,
        writable: !0,
        value: c
    }) : c !== b && (void 0 === $jscomp.propertyToPolyfillSymbol[f] && (b = 1E9 * Math.random() >>> 0, $jscomp.propertyToPolyfillSymbol[f] = $jscomp.IS_SYMBOL_NATIVE ?
        $jscomp.global.Symbol(f) : $jscomp.POLYFILL_PREFIX + b + "$" + f), $jscomp.defineProperty(d, $jscomp.propertyToPolyfillSymbol[f], {
        configurable: !0,
        writable: !0,
        value: c
    })))
};
$jscomp.underscoreProtoCanBeSet = function () {
    var a = {
            a: !0
        },
        c = {};
    try {
        return c.__proto__ = a, c.a
    } catch (b) {}
    return !1
};
$jscomp.setPrototypeOf = $jscomp.TRUST_ES6_POLYFILLS && "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function (a, c) {
    a.__proto__ = c;
    if (a.__proto__ !== c) throw new TypeError(a + " is not extensible");
    return a
} : null;
$jscomp.arrayIteratorImpl = function (a) {
    var c = 0;
    return function () {
        return c < a.length ? {
            done: !1,
            value: a[c++]
        } : {
            done: !0
        }
    }
};
$jscomp.arrayIterator = function (a) {
    return {
        next: $jscomp.arrayIteratorImpl(a)
    }
};
$jscomp.makeIterator = function (a) {
    var c = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
    if (c) return c.call(a);
    if ("number" == typeof a.length) return $jscomp.arrayIterator(a);
    throw Error(String(a) + " is not an iterable or ArrayLike");
};
$jscomp.generator = {};
$jscomp.generator.ensureIteratorResultIsObject_ = function (a) {
    if (!(a instanceof Object)) throw new TypeError("Iterator result " + a + " is not an object");
};
$jscomp.generator.Context = function () {
    this.isRunning_ = !1;
    this.yieldAllIterator_ = null;
    this.yieldResult = void 0;
    this.nextAddress = 1;
    this.finallyAddress_ = this.catchAddress_ = 0;
    this.finallyContexts_ = this.abruptCompletion_ = null
};
$jscomp.generator.Context.prototype.start_ = function () {
    if (this.isRunning_) throw new TypeError("Generator is already running");
    this.isRunning_ = !0
};
$jscomp.generator.Context.prototype.stop_ = function () {
    this.isRunning_ = !1
};
$jscomp.generator.Context.prototype.jumpToErrorHandler_ = function () {
    this.nextAddress = this.catchAddress_ || this.finallyAddress_
};
$jscomp.generator.Context.prototype.next_ = function (a) {
    this.yieldResult = a
};
$jscomp.generator.Context.prototype.throw_ = function (a) {
    this.abruptCompletion_ = {
        exception: a,
        isException: !0
    };
    this.jumpToErrorHandler_()
};
$jscomp.generator.Context.prototype["return"] = function (a) {
    this.abruptCompletion_ = {
        "return": a
    };
    this.nextAddress = this.finallyAddress_
};
$jscomp.generator.Context.prototype.jumpThroughFinallyBlocks = function (a) {
    this.abruptCompletion_ = {
        jumpTo: a
    };
    this.nextAddress = this.finallyAddress_
};
$jscomp.generator.Context.prototype.yield = function (a, c) {
    this.nextAddress = c;
    return {
        value: a
    }
};
$jscomp.generator.Context.prototype.yieldAll = function (a, c) {
    var b = $jscomp.makeIterator(a),
        d = b.next();
    $jscomp.generator.ensureIteratorResultIsObject_(d);
    if (d.done) this.yieldResult = d.value, this.nextAddress = c;
    else return this.yieldAllIterator_ = b, this.yield(d.value, c)
};
$jscomp.generator.Context.prototype.jumpTo = function (a) {
    this.nextAddress = a
};
$jscomp.generator.Context.prototype.jumpToEnd = function () {
    this.nextAddress = 0
};
$jscomp.generator.Context.prototype.setCatchFinallyBlocks = function (a, c) {
    this.catchAddress_ = a;
    void 0 != c && (this.finallyAddress_ = c)
};
$jscomp.generator.Context.prototype.setFinallyBlock = function (a) {
    this.catchAddress_ = 0;
    this.finallyAddress_ = a || 0
};
$jscomp.generator.Context.prototype.leaveTryBlock = function (a, c) {
    this.nextAddress = a;
    this.catchAddress_ = c || 0
};
$jscomp.generator.Context.prototype.enterCatchBlock = function (a) {
    this.catchAddress_ = a || 0;
    a = this.abruptCompletion_.exception;
    this.abruptCompletion_ = null;
    return a
};
$jscomp.generator.Context.prototype.enterFinallyBlock = function (a, c, b) {
    b ? this.finallyContexts_[b] = this.abruptCompletion_ : this.finallyContexts_ = [this.abruptCompletion_];
    this.catchAddress_ = a || 0;
    this.finallyAddress_ = c || 0
};
$jscomp.generator.Context.prototype.leaveFinallyBlock = function (a, c) {
    var b = this.finallyContexts_.splice(c || 0)[0];
    if (b = this.abruptCompletion_ = this.abruptCompletion_ || b) {
        if (b.isException) return this.jumpToErrorHandler_();
        void 0 != b.jumpTo && this.finallyAddress_ < b.jumpTo ? (this.nextAddress = b.jumpTo, this.abruptCompletion_ = null) : this.nextAddress = this.finallyAddress_
    } else this.nextAddress = a
};
$jscomp.generator.Context.prototype.forIn = function (a) {
    return new $jscomp.generator.Context.PropertyIterator(a)
};
$jscomp.generator.Context.PropertyIterator = function (a) {
    this.object_ = a;
    this.properties_ = [];
    for (var c in a) this.properties_.push(c);
    this.properties_.reverse()
};
$jscomp.generator.Context.PropertyIterator.prototype.getNext = function () {
    for (; 0 < this.properties_.length;) {
        var a = this.properties_.pop();
        if (a in this.object_) return a
    }
    return null
};
$jscomp.generator.Engine_ = function (a) {
    this.context_ = new $jscomp.generator.Context;
    this.program_ = a
};
$jscomp.generator.Engine_.prototype.next_ = function (a) {
    this.context_.start_();
    if (this.context_.yieldAllIterator_) return this.yieldAllStep_(this.context_.yieldAllIterator_.next, a, this.context_.next_);
    this.context_.next_(a);
    return this.nextStep_()
};
$jscomp.generator.Engine_.prototype.return_ = function (a) {
    this.context_.start_();
    var c = this.context_.yieldAllIterator_;
    if (c) return this.yieldAllStep_("return" in c ? c["return"] : function (b) {
        return {
            value: b,
            done: !0
        }
    }, a, this.context_["return"]);
    this.context_["return"](a);
    return this.nextStep_()
};
$jscomp.generator.Engine_.prototype.throw_ = function (a) {
    this.context_.start_();
    if (this.context_.yieldAllIterator_) return this.yieldAllStep_(this.context_.yieldAllIterator_["throw"], a, this.context_.next_);
    this.context_.throw_(a);
    return this.nextStep_()
};
$jscomp.generator.Engine_.prototype.yieldAllStep_ = function (a, c, b) {
    try {
        var d = a.call(this.context_.yieldAllIterator_, c);
        $jscomp.generator.ensureIteratorResultIsObject_(d);
        if (!d.done) return this.context_.stop_(), d;
        var f = d.value
    } catch (e) {
        return this.context_.yieldAllIterator_ = null, this.context_.throw_(e), this.nextStep_()
    }
    this.context_.yieldAllIterator_ = null;
    b.call(this.context_, f);
    return this.nextStep_()
};
$jscomp.generator.Engine_.prototype.nextStep_ = function () {
    for (; this.context_.nextAddress;) try {
        var a = this.program_(this.context_);
        if (a) return this.context_.stop_(), {
            value: a.value,
            done: !1
        }
    } catch (c) {
        this.context_.yieldResult = void 0, this.context_.throw_(c)
    }
    this.context_.stop_();
    if (this.context_.abruptCompletion_) {
        a = this.context_.abruptCompletion_;
        this.context_.abruptCompletion_ = null;
        if (a.isException) throw a.exception;
        return {
            value: a["return"],
            done: !0
        }
    }
    return {
        value: void 0,
        done: !0
    }
};
$jscomp.generator.Generator_ = function (a) {
    this.next = function (c) {
        return a.next_(c)
    };
    this["throw"] = function (c) {
        return a.throw_(c)
    };
    this["return"] = function (c) {
        return a.return_(c)
    };
    this[Symbol.iterator] = function () {
        return this
    }
};
$jscomp.generator.createGenerator = function (a, c) {
    var b = new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(c));
    $jscomp.setPrototypeOf && a.prototype && $jscomp.setPrototypeOf(b, a.prototype);
    return b
};
$jscomp.asyncExecutePromiseGenerator = function (a) {
    function c(d) {
        return a.next(d)
    }

    function b(d) {
        return a["throw"](d)
    }
    return new Promise(function (d, f) {
        function e(l) {
            l.done ? d(l.value) : Promise.resolve(l.value).then(c, b).then(e, f)
        }
        e(a.next())
    })
};
$jscomp.asyncExecutePromiseGeneratorFunction = function (a) {
    return $jscomp.asyncExecutePromiseGenerator(a())
};
$jscomp.asyncExecutePromiseGeneratorProgram = function (a) {
    return $jscomp.asyncExecutePromiseGenerator(new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(a)))
};
var VERSION = "1.13.1",
    DEFAULT_TIMEOUT = 12E4,
    VERIFY_DEFAULT_TIMEOUT = 3E5,
    AUTHENTICATOR_TRANSPORTS = ["usb"],
    GTheader = "R29UcnVzdC1JZGVtLVBLSQ==",
    sUserName = "GoTrustID.com",
    TOKEN_MIN_PIN_LEN = 4,
    TOKEN_MAX_PIN_LEN = 63,
    TOKEN_MAX_SOPIN_LEN = 16,
    TOKEN_MIN_SOPIN_LEN = 8,
    CMD_KeyAgreement = 224,
    CMD_ReadCertificate = 225,
    CMD_TokenInfo = 226,
    CMD_Sign = 227,
    CMD_SignWithPIN = 229,
    CMD_ImportCertificate = 231,
    CMD_CHANGE_PIN = 232,
    CMD_UNLOCK_PIN = 233,
    CMD_DELEE_CERT = 235,
    CMD_CLEAR_TOKEN = 236,
    CMD_INIT_TOKEN = 237,
    CMD_GenKeyPair = 238,
    CMD_FactoryReset =
    239,
    CMD_ImportCertificate2 = 247,
    CMD_GetCertExtras = 178,
    CMD_REQUESTCSR = 234,
    CMD_GenRsaKeyPair = 230,
    CMD_REQUESTP256CSR = 193,
    CMD_REQUESTP384CSR = 194,
    CMD_REQUESTP521CSR = 195,
    CMD_GenRsaKeyPair_AFTER_CLEAR = 196,
    CMD_REQUESTCSR_AFTER_CLEAR = 197,
    CMD_REQUESTP256CSR_AFTER_CLEAR = 198,
    CMD_REQUESTP384CSR_AFTER_CLEAR = 199,
    CMD_REQUESTP521CSR_AFTER_CLEAR = 200,
    g_encryptedPIN, g_platformECpublickey, ALG_RSA2048SHA1 = 1,
    ALG_RSA2048SHA256 = 2,
    ALG_RSA2048SHA384 = 3,
    ALG_RSA2048SHA512 = 4,
    ALG_RSA2048SHA1_PSS = 5,
    ALG_RSA2048SHA256_PSS = 6,
    ALG_RSA2048SHA384_PSS =
    7,
    ALG_RSA2048SHA512_PSS = 8,
    ALG_ECDSASHA1 = 9,
    ALG_ECDSASHA256 = 10,
    ALG_ECDSASHA384 = 11,
    ALG_ECDSASHA512 = 12,
    ALG_RSA2048SHA1_PreHash = 17,
    ALG_RSA2048SHA256_PreHash = 18,
    ALG_RSA2048SHA384_PreHash = 19,
    ALG_RSA2048SHA512_PreHash = 20,
    ALG_RSA2048SHA1_PSS_PreHash = 21,
    ALG_RSA2048SHA256_PSS_PreHash = 22,
    ALG_RSA2048SHA384_PSS_PreHash = 23,
    ALG_RSA2048SHA512_PSS_PreHash = 24,
    ALG_ECDSASHA1_PreHash = 25,
    ALG_ECDSASHA256_PreHash = 26,
    ALG_ECDSASHA384_PreHash = 27,
    ALG_ECDSASHA512_PreHash = 28,
    PIN_FORMAT_FREE = 0,
    PIN_FORMAT_NUMBER = 1,
    PIN_FORMAT_LOWERCASE =
    2,
    PIN_FORMAT_HIGERCASE = 4,
    PIN_FORMAT_SYMBOL = 8,
    PIN_SETUP_ENG_MASK = 240,
    PIN_SETUP_ENG_OK = 0,
    PIN_SETUP_ENG_ASK = 128,
    PIN_SETUP_ENG_NO = 64,
    PIN_SETUP_ENG_SPEC = 192,
    PIN_SETUP_ENG_HIGHCASE = 32,
    PIN_SETUP_ENG_LOWCASE = 16,
    PIN_SETUP_NUM_MASK = 3,
    PIN_SETUP_NUM_OK = 0,
    PIN_SETUP_NUM_ASK = 1,
    PIN_SETUP_NUM_NO = 3,
    PIN_SETUP_SYM_MASK = 12,
    PIN_SETUP_SYM_OK = 0,
    PIN_SETUP_SYM_ASK = 4,
    PIN_SETUP_SYM_NO = 12,
    RSA_2048 = 1,
    EC_secp256r1 = 2,
    EC_secp384r1 = 3,
    EC_secp521r1 = 4,
    OutputType_RAW = 1,
    OutputType_CSR = 2,
    TOKEN_FLAGS_PINEXPIRED = 1,
    TOKEN_FLAGS_INITIALIZED =
    2;

function IKPException(a) {
    this.code = a
}

function toUTF8Array(a) {
    for (var c = [], b = 0; b < a.length; b++) {
        var d = a.charCodeAt(b);
        128 > d ? c.push(d) : 2048 > d ? c.push(192 | d >> 6, 128 | d & 63) : 55296 > d || 57344 <= d ? c.push(224 | d >> 12, 128 | d >> 6 & 63, 128 | d & 63) : (b++, d = 65536 + ((d & 1023) << 10 | a.charCodeAt(b) & 1023), c.push(240 | d >> 18, 128 | d >> 12 & 63, 128 | d >> 6 & 63, 128 | d & 63))
    }
    return new Uint8Array(c)
}

function hexStringToArrayBuffer(a) {
    a = a.replace(/^0x/, "");
    0 != a.length % 2 && console.log("WARNING: expecting an even number of characters in the hexString");
    var c = a.match(/[G-Z\s]/i);
    c && console.log("WARNING: found non-hex characters", c);
    a = a.match(/[\dA-F]{2}/gi).map(function (b) {
        return parseInt(b, 16)
    });
    return new Uint8Array(a)
}
var ConverVersionFormat = function (a) {
        for (var c = "", b = 0; b < a.length; b++) c += a[b].toString(16), c += ".";
        return c
    },
    ConverSNFormat = function (a) {
        for (var c = "", b = 0; b < a.length; b++) 16 > a[b] && (c += "0"), c += a[b].toString(16);
        return c
    };

function computingSessionKey(a, c, b) {
    var d, f, e, l, h, g, q, k, m, n, r, p, t, u, v;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (w) {
        switch (w.nextAddress) {
            case 1:
                return w.yield(crypto.subtle.digest("SHA-256", a), 2);
            case 2:
                return d = w.yieldResult, f = new Uint8Array(64), f.fill(0), f.set(c, 0), e = new Uint8Array(16), e.fill(0), l = b, h = base64EncodeURL(l.slice(1, 33)), g = base64EncodeURL(l.slice(33, 65)), w.yield(window.crypto.subtle.importKey("jwk", {
                        kty: "EC",
                        crv: "P-256",
                        x: h,
                        y: g,
                        ext: !0
                    }, {
                        name: "ECDH",
                        namedCurve: "P-256"
                    },
                    !0, []), 3);
            case 3:
                return n = w.yieldResult, w.yield(window.crypto.subtle.generateKey({
                    name: "ECDH",
                    namedCurve: "P-256"
                }, !0, ["deriveKey", "deriveBits"]), 4);
            case 4:
                return r = w.yieldResult, w.yield(window.crypto.subtle.exportKey("raw", r.publicKey), 5);
            case 5:
                return q = w.yieldResult, w.yield(window.crypto.subtle.deriveBits({
                    name: "ECDH",
                    namedCurve: "P-256",
                    "public": n
                }, r.privateKey, 256).then(function (z) {
                    return crypto.subtle.digest("SHA-256", new Uint8Array(z))
                }).then(function (z) {
                    return crypto.subtle.importKey("raw",
                        z, "aes-cbc", !1, ["encrypt"])
                }), 6);
            case 6:
                return p = w.yieldResult, w.yield(crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv: e
                }, p, new Uint8Array(d)), 7);
            case 7:
                return k = w.yieldResult, w.yield(crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv: e
                }, p, new Uint8Array(f)), 8);
            case 8:
                return m = w.yieldResult, t = new Uint8Array(q), u = new Uint8Array(k.slice(0, 16)), v = (new Uint8Array(m)).slice(0, 64), w["return"]({
                    bExportECPublicKeyArray: t,
                    bEcryptedOldPINHash: u,
                    bEncryptedNEWPIN: v
                })
        }
    })
}

function isAllowedSymbol(a) {
    return 33 <= a && 47 >= a || 58 <= a && 64 >= a || 91 <= a && 96 >= a || 123 <= a && 126 >= a ? !0 : !1
}

function checkPINFormatLevel(a, c) {
    var b = 0;
    if (c == PIN_FORMAT_FREE) return !0;
    for (var d = 0; d < a.byteLength; d++) {
        var f = a[d];
        48 <= f && 57 >= f ? b |= PIN_FORMAT_NUMBER : 97 <= f && 122 >= f ? b |= PIN_FORMAT_LOWERCASE : 65 <= f && 90 >= f ? b |= PIN_FORMAT_HIGERCASE : isAllowedSymbol(f) && (b |= PIN_FORMAT_SYMBOL)
    }
    switch (c & 192) {
        case 128:
            if (0 == (c & 48) && 0 == (b & (PIN_FORMAT_HIGERCASE | PIN_FORMAT_LOWERCASE)) || 16 == (c & 48) && 0 == (b & PIN_FORMAT_LOWERCASE) || 32 == (c & 48) && 0 == (b & PIN_FORMAT_HIGERCASE) || 48 == (c & 48) && (b & (PIN_FORMAT_HIGERCASE | PIN_FORMAT_LOWERCASE)) != (PIN_FORMAT_HIGERCASE |
                    PIN_FORMAT_LOWERCASE)) return !1;
            break;
        case 64:
            if (48 == (c & 48) && 0 != (b & (PIN_FORMAT_HIGERCASE | PIN_FORMAT_LOWERCASE)) || 16 == (c & 16) && 0 != (b & PIN_FORMAT_LOWERCASE) || 32 == (c & 16) && 0 != (b & PIN_FORMAT_HIGERCASE)) return !1;
            break;
        case 192:
            if (32 == (c & 32) && (0 == (b & PIN_FORMAT_HIGERCASE) || (b & PIN_FORMAT_LOWERCASE) == PIN_FORMAT_LOWERCASE) || 16 == (c & 16) && ((b & PIN_FORMAT_HIGERCASE) == PIN_FORMAT_HIGERCASE || 0 == (b & PIN_FORMAT_LOWERCASE))) return !1
    }
    switch (c & 3) {
        case 1:
            if ((b & PIN_FORMAT_NUMBER) != PIN_FORMAT_NUMBER) return !1;
            break;
        case 3:
            if ((b &
                    PIN_FORMAT_NUMBER) == PIN_FORMAT_NUMBER) return !1
    }
    switch (c & 12) {
        case 4:
            if ((b & PIN_FORMAT_SYMBOL) != PIN_FORMAT_SYMBOL) return !1;
            break;
        case 12:
            if ((b & PIN_FORMAT_SYMBOL) == PIN_FORMAT_SYMBOL) return !1
    }
    return !0
}

function checkPINFormatLevel_V2(a, c) {
    var b = CTAP1_ERR_SUCCESS,
        d = 0;
    if (c == PIN_FORMAT_FREE) return b;
    for (var f = 0; f < a.byteLength; f++) {
        var e = a[f];
        48 <= e && 57 >= e ? d |= PIN_FORMAT_NUMBER : 97 <= e && 122 >= e ? d |= PIN_FORMAT_LOWERCASE : 65 <= e && 90 >= e ? d |= PIN_FORMAT_HIGERCASE : isAllowedSymbol(e) && (d |= PIN_FORMAT_SYMBOL)
    }
    switch (c & 192) {
        case 128:
            if (0 == (c & 48) && 0 == (d & (PIN_FORMAT_HIGERCASE | PIN_FORMAT_LOWERCASE))) return SETTING_ERR_USERPIN_NEED_LETTER;
            if (16 == (c & 48) && 0 == (d & PIN_FORMAT_LOWERCASE)) return SETTING_ERR_USERPIN_NEED_LOWERCASE;
            if (32 == (c & 48) && 0 == (d & PIN_FORMAT_HIGERCASE)) return SETTING_ERR_USERPIN_NEED_UPPERCASE;
            if (48 == (c & 48) && (d & (PIN_FORMAT_HIGERCASE | PIN_FORMAT_LOWERCASE)) != (PIN_FORMAT_HIGERCASE | PIN_FORMAT_LOWERCASE)) return SETTING_ERR_USERPIN_NEED_LETTER;
            break;
        case 64:
            if (48 == (c & 48) && 0 != (d & (PIN_FORMAT_HIGERCASE | PIN_FORMAT_LOWERCASE))) return SETTING_ERR_USERPIN_BAN_LETTER;
            if (16 == (c & 16) && 0 != (d & PIN_FORMAT_LOWERCASE)) return SETTING_ERR_USERPIN_BAN_LOWERCASE;
            if (32 == (c & 16) && 0 != (d & PIN_FORMAT_HIGERCASE)) return SETTING_ERR_USERPIN_BAN_UPPERCASE;
            break;
        case 192:
            if (32 == (c & 32)) {
                if (0 == (d & PIN_FORMAT_HIGERCASE)) return SETTING_ERR_USERPIN_NEED_UPPERCASE;
                if ((d & PIN_FORMAT_LOWERCASE) == PIN_FORMAT_LOWERCASE) return SETTING_ERR_USERPIN_BAN_LOWERCASE
            }
            if (16 == (c & 16)) {
                if ((d & PIN_FORMAT_HIGERCASE) == PIN_FORMAT_HIGERCASE) return SETTING_ERR_USERPIN_BAN_UPPERCASE;
                if (0 == (d & PIN_FORMAT_LOWERCASE)) return SETTING_ERR_USERPIN_NEED_LOWERCASE
            }
    }
    switch (c & 3) {
        case 1:
            if ((d & PIN_FORMAT_NUMBER) != PIN_FORMAT_NUMBER) return SETTING_ERR_USERPIN_NEED_NUMBER;
            break;
        case 3:
            if ((d & PIN_FORMAT_NUMBER) ==
                PIN_FORMAT_NUMBER) return SETTING_ERR_USERPIN_BAN_NUMBER
    }
    switch (c & 12) {
        case 4:
            if ((d & PIN_FORMAT_SYMBOL) != PIN_FORMAT_SYMBOL) return SETTING_ERR_USERPIN_NEED_SYMBOL;
            break;
        case 12:
            if ((d & PIN_FORMAT_SYMBOL) == PIN_FORMAT_SYMBOL) return SETTING_ERR_USERPIN_BAN_SYMBOL
    }
    return b
}

function GTIDEM_isValidTokenParams(a, c) {
    var b = new GTIdemJs;
    b.statusCode = CTAP1_ERR_SUCCESS;
    try {
        var d = CBOR.decode(a.buffer)
    } catch (e) {
        return b.statusCode = SETTING_ERR_CBOR_PARSING, b
    }
    if (c === CMD_INIT_TOKEN) {
        if (void 0 != d.pinExpired) {
            var f = d.pinExpired;
            if ("boolean" !== typeof f) return b.statusCode = SETTING_ERR_CBOR_UNEXPECTED_TYPE, b
        } else return b.statusCode = CTAP2_ERR_MISSING_PARAMETER, b;
        if (void 0 != d.soPIN) {
            if (d.soPIN.byteLength > TOKEN_MAX_SOPIN_LEN) return b.statusCode = SETTING_ERR_SOPIN_LEN_TOO_LONG, b;
            if (d.soPIN.byteLength <
                TOKEN_MIN_SOPIN_LEN) return b.statusCode = SETTING_ERR_SOPIN_LEN_TOO_SHORT, b
        } else return b.statusCode = CTAP2_ERR_MISSING_PARAMETER, b;
        if (void 0 != d.userPIN) {
            if (d.userPIN.byteLength < TOKEN_MIN_PIN_LEN) return b.statusCode = SETTING_ERR_USERPIN_LEN_TOO_SHORT, b;
            if (d.userPIN.byteLength > TOKEN_MAX_PIN_LEN) return b.statusCode = SETTING_ERR_USERPIN_LEN_TOO_LONG, b;
            if (void 0 != d.allowedRPID) {
                if (0 != d.allowedRPID.byteLength % 8) {
                    b.statusCode = SETTING_ERR_INVAILD_DOMAINS;
                    return
                }
            } else return b.statusCode = CTAP2_ERR_MISSING_PARAMETER,
                b;
            if (void 0 != d.pinLevel) {
                if (d.pinLevel == PIN_FORMAT_FREE) return b.statusCode = SETTING_ERR_USERPIN_ALLOW_ALL, b;
                if (d.pinLevel == (PIN_SETUP_ENG_NO | PIN_SETUP_ENG_HIGHCASE | PIN_SETUP_ENG_LOWCASE | PIN_SETUP_NUM_NO | PIN_SETUP_SYM_NO)) return b.statusCode = SETTING_ERR_USERPIN_REJECT_ALL, b
            } else return b.statusCode = CTAP2_ERR_MISSING_PARAMETER, b;
            if (void 0 != d.pinRetry) {
                if (0 == d.pinRetry || 15 < d.pinRetry) return b.statusCode = SETTING_ERR_INVAILD_USERPIN_RETRY, b
            } else return b.statusCode = CTAP2_ERR_MISSING_PARAMETER, b;
            if (void 0 !=
                d.pinMinLen) {
                if (d.pinMinLen < TOKEN_MIN_PIN_LEN || d.pinMinLen > TOKEN_MAX_PIN_LEN) b.statusCode = SETTING_ERR_INVAILD_USERPIN_MIN_LEN
            } else b.statusCode = CTAP2_ERR_MISSING_PARAMETER;
            return b
        }
        b.statusCode = CTAP2_ERR_MISSING_PARAMETER
    } else if (c === CMD_UNLOCK_PIN) {
        if (void 0 != d.pinExpired) {
            if (f = d.pinExpired, "boolean" !== typeof f) return b.statusCode = SETTING_ERR_CBOR_UNEXPECTED_TYPE, b
        } else return b.statusCode = CTAP2_ERR_MISSING_PARAMETER, b;
        if (void 0 != d.userPIN) {
            if (d.userPIN.byteLength < TOKEN_MIN_PIN_LEN) return b.statusCode =
                SETTING_ERR_USERPIN_LEN_TOO_SHORT, b;
            d.userPIN.byteLength > TOKEN_MAX_PIN_LEN && (b.statusCode = SETTING_ERR_USERPIN_LEN_TOO_LONG)
        } else b.statusCode = CTAP2_ERR_MISSING_PARAMETER;
        return b
    }
}

function GTIDEM_isValidPIN(a, c) {
    return a.length < c[2] || a.length > c[3] || !checkPINFormatLevel(a, c[1]) ? !1 : !0
}

function GTIDEM_isValidPIN_V2(a, c) {
    var b = new GTIdemJs;
    b.statusCode = CTAP1_ERR_SUCCESS;
    b.statusCode = a.length < c[2] ? IKP_ERR_SETTING_USERPIN_LEN : a.length > c[3] ? IKP_ERR_SETTING_USERPIN_LEN : checkPINFormatLevel_V2(a, c[1]);
    return b
}

function GTIDEM_GenPINParams(a, c, b) {
    var d, f, e, l, h;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (g) {
        if (1 == g.nextAddress) return g.yield(GTIDEM_GetTokenInfo(a).then(function (q) {
            return q
        }), 2);
        if (3 != g.nextAddress) {
            d = g.yieldResult;
            if (d.statusCode != CTAP1_ERR_SUCCESS) return g["return"](d);
            if (0 == d.pinRetry) return d.statusCode = CTAP2_ERR_PIN_BLOCKED, g["return"](d);
            f = d.ecpoint;
            e = d.flags;
            if (JSON.stringify(c) == JSON.stringify(b)) return d.statusCode = SETTING_ERR_USERPIN_SAME, g["return"](d);
            if (void 0 !=
                e) {
                l = checkPINFormatLevel_V2(b, e[1]);
                if (l != CTAP1_ERR_SUCCESS) return d.statusCode = l, g["return"](d);
                if (b.length < e[2]) return d.statusCode = SETTING_ERR_USERPIN_LEN_TOO_SHORT, g["return"](d);
                if (b.length > e[3]) return d.statusCode = SETTING_ERR_USERPIN_LEN_TOO_LONG, g["return"](d)
            } else return d.statusCode = WEB_ERR_OperationAbort, g["return"](d);
            return g.yield(computingSessionKey(c, b, f), 3)
        }
        h = g.yieldResult;
        d.statusCode = CTAP1_ERR_SUCCESS;
        d.encOldPINHashed = h.bEcryptedOldPINHash;
        d.encNewPIN = h.bEncryptedNEWPIN;
        d.hostEcpoint =
            h.bExportECPublicKeyArray;
        return g["return"](d)
    })
}

function GTIDEM_ChangeUserPINwithInterval(a, c, b, d) {
    var f, e, l, h, g, q;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (k) {
        if (1 == k.nextAddress) return f = void 0, k.yield(GTIDEM_GetTokenInfo(b), 2);
        if (3 != k.nextAddress) {
            e = k.yieldResult;
            if (e.statusCode != CTAP1_ERR_SUCCESS) return void 0 != d && d(e), k["return"](e);
            if (0 == e.pinRetry) return e.statusCode = CTAP2_ERR_PIN_BLOCKED, void 0 != d && d(e), k["return"](e);
            l = e.ecpoint;
            h = e.flags;
            if (JSON.stringify(a) == JSON.stringify(c)) return e.statusCode = SETTING_ERR_USERPIN_SAME,
                void 0 != d && d(e), k["return"](e);
            if (void 0 != h) {
                g = checkPINFormatLevel_V2(c, h[1]);
                if (g != CTAP1_ERR_SUCCESS) return e.statusCode = g, void 0 != d && d(e), k["return"](e);
                if (c.length < h[2]) return e.statusCode = SETTING_ERR_USERPIN_LEN_TOO_SHORT, void 0 != d && d(e), k["return"](e);
                if (c.length > h[3]) return e.statusCode = SETTING_ERR_USERPIN_LEN_TOO_LONG, void 0 != d && d(e), k["return"](e)
            } else return e.statusCode = WEB_ERR_OperationAbort, void 0 != d && d(e), k["return"](e);
            return k.yield(computingSessionKey(a, c, l), 3)
        }
        f = k.yieldResult;
        q = setInterval(function () {
            return $jscomp.asyncExecutePromiseGeneratorProgram(function (m) {
                clearInterval(q);
                return m.yield(GTIDEM_ChangeUserPIN_V1(b, f.bExportECPublicKeyArray, f.bEcryptedOldPINHash, f.bEncryptedNEWPIN).then(function (n) {
                    void 0 != d && d(n);
                    return n
                }), 0)
            })
        }, 200);
        k.jumpToEnd()
    })
}

function GTIDEM_ChangeUserPIN(a, c, b, d) {
    var f, e, l, h, g, q;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (k) {
        switch (k.nextAddress) {
            case 1:
                return f = get_browser(), "Safari" == f.name && 15 <= parseInt(f.major) ? k.yield(GTIDEM_ChangeUserPINwithInterval(a, c, b, d), 7) : k.yield(GTIDEM_GetTokenInfo(b), 4);
            case 4:
                e = k.yieldResult;
                if (e.statusCode != CTAP1_ERR_SUCCESS) return void 0 != d && d(e), k["return"](e);
                if (0 == e.pinRetry) return e.statusCode = CTAP2_ERR_PIN_BLOCKED, void 0 != d && d(e), k["return"](e);
                l = e.ecpoint;
                h = e.flags;
                if (JSON.stringify(a) == JSON.stringify(c)) return e.statusCode = SETTING_ERR_USERPIN_SAME, void 0 != d && d(e), k["return"](e);
                if (void 0 != h) {
                    g = checkPINFormatLevel_V2(c, h[1]);
                    if (g != CTAP1_ERR_SUCCESS) return e.statusCode = g, void 0 != d && d(e), k["return"](e);
                    if (c.length < h[2]) return e.statusCode = SETTING_ERR_USERPIN_LEN_TOO_SHORT, void 0 != d && d(e), k["return"](e);
                    if (c.length > h[3]) return e.statusCode = SETTING_ERR_USERPIN_LEN_TOO_LONG, void 0 != d && d(e), k["return"](e)
                } else return e.statusCode = WEB_ERR_OperationAbort, k["return"](e);
                return k.yield(computingSessionKey(a, c, l), 5);
            case 5:
                return q = k.yieldResult, k.yield(GTIDEM_ChangeUserPIN_V1(b, q.bExportECPublicKeyArray, q.bEcryptedOldPINHash, q.bEncryptedNEWPIN).then(function (m) {
                    void 0 != d && d(m);
                    return m
                }), 6);
            case 6:
                return k["return"](k.yieldResult);
            case 7:
                return k["return"](k.yieldResult)
        }
    })
}

function GTIDEM_ChangeUserPIN_V1(a, c, b, d) {
    var f, e, l, h, g, q, k, m, n, r, p;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (t) {
        return 1 == t.nextAddress ? (void 0 == a || 0 == a.byteLength ? f = new Uint8Array(0) : (f = new Uint8Array(4 + a.byteLength), f[0] = 223, f[1] = 32, f[2] = a.byteLength >> 8, f[3] = a.byteLength, f.set(a, 4)), e = new Uint8Array(32), window.crypto.getRandomValues(e), l = new Uint8Array(4 + c.byteLength), l[0] = 223, l[1] = 4, l[2] = c.byteLength >> 8, l[3] = c.byteLength, l.set(new Uint8Array(c), 4), h = new Uint8Array(4 + b.byteLength),
            h[0] = 223, h[1] = 5, h[2] = b.byteLength >> 8, h[3] = b.byteLength, h.set(new Uint8Array(b), 4), g = new Uint8Array(4 + d.byteLength), g[0] = 223, g[1] = 7, g[2] = d.byteLength >> 8, g[3] = d.byteLength, g.set(new Uint8Array(d), 4), q = f.byteLength + l.byteLength + h.byteLength + g.byteLength, k = Uint8Array.from(window.atob(GTheader), function (u) {
                return u.charCodeAt(0)
            }), m = new Uint8Array(3), m[0] = CMD_CHANGE_PIN, m[1] = q >> 8, m[2] = q, n = _appendBuffer(k, m), n = _appendBuffer(n, f), n = _appendBuffer(n, l), n = _appendBuffer(n, h), n = _appendBuffer(n, g), r = {
                challenge: e,
                userVerification: "discouraged",
                timeout: DEFAULT_TIMEOUT
            }, p = [{
                id: n,
                type: "public-key",
                transports: AUTHENTICATOR_TRANSPORTS
            }], r.allowCredentials = p, t.yield(navigator.credentials.get({
                publicKey: r
            }).then(function (u) {
                var v = new GTIdemJs;
                v.parsePKIoverFIDOResponse(u.response.signature, CMD_CHANGE_PIN);
                return v
            })["catch"](function (u) {
                var v = new GTIdemJs;
                v.ConvertWebError(u.name, u.message);
                return v
            }), 2)) : t["return"](t.yieldResult)
    })
}

function GTIDEM_GenP256CSR(a, c, b) {
    b = void 0 === b ? !1 : b;
    var d, f, e, l, h, g, q, k, m, n;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (r) {
        if (1 == r.nextAddress) {
            d = new Uint8Array(32);
            window.crypto.getRandomValues(d);
            void 0 == c || 0 == c.byteLength ? f = new Uint8Array(0) : (f = new Uint8Array(4 + c.byteLength), f[0] = 223, f[1] = 38, f[2] = c.byteLength >> 8, f[3] = c.byteLength, f.set(c, 4));
            void 0 == a || 0 == a.byteLength ? e = new Uint8Array(0) : (e = new Uint8Array(4 + a.byteLength), e[0] = 223, e[1] = 32, e[2] = a.byteLength >> 8, e[3] = a.byteLength, e.set(a,
                4));
            if (45 < e.byteLength + f.byteLength) return l = new GTIdemJs, l.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, r["return"](l);
            if (44 < f.byteLength) return h = new GTIdemJs, h.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, r["return"](h);
            g = f.byteLength + e.byteLength;
            q = Uint8Array.from(window.atob(GTheader), function (p) {
                return p.charCodeAt(0)
            });
            k = new Uint8Array(3);
            k[0] = 0 == b ? CMD_REQUESTP256CSR : CMD_REQUESTP256CSR_AFTER_CLEAR;
            k[1] = g >> 8;
            k[2] = g;
            m = _appendBuffer(q, k);
            m = _appendBuffer(m, e);
            m = _appendBuffer(m, f);
            n = {
                challenge: d,
                rp: {
                    name: "GoTrustID Inc."
                },
                user: {
                    id: m,
                    name: sUserName,
                    displayName: sUserName
                },
                authenticatorSelection: {
                    userVerification: "required",
                    requireResidentKey: !1,
                    residentKey: "discouraged",
                    authenticatorAttachment: "cross-platform"
                },
                timeout: VERIFY_DEFAULT_TIMEOUT,
                attestation: "direct",
                pubKeyCredParams: [{
                    type: "public-key",
                    alg: -7
                }, {
                    type: "public-key",
                    alg: -257
                }]
            };
            return r.yield(navigator.credentials.create({
                publicKey: n
            }).then(function (p) {
                p = CBOR.decode(p.response.attestationObject);
                p = parseAuthData(p.authData).credID;
                p = p.buffer.slice(p.byteOffset,
                    p.byteLength + p.byteOffset);
                var t = new GTIdemJs;
                t.parsePKIoverFIDOResponse(p, CMD_REQUESTP256CSR);
                return t
            })["catch"](function (p) {
                var t = new GTIdemJs;
                t.ConvertWebError(p.name, p.message);
                return t
            }), 2)
        }
        return r["return"](r.yieldResult)
    })
}

function GTIDEM_GenP384CSR(a, c, b) {
    b = void 0 === b ? !1 : b;
    var d, f, e, l, h, g, q, k, m, n;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (r) {
        if (1 == r.nextAddress) {
            d = new Uint8Array(32);
            window.crypto.getRandomValues(d);
            void 0 == c || 0 == c.byteLength ? f = new Uint8Array(0) : (f = new Uint8Array(4 + c.byteLength), f[0] = 223, f[1] = 38, f[2] = c.byteLength >> 8, f[3] = c.byteLength, f.set(c, 4));
            void 0 == a || 0 == a.byteLength ? e = new Uint8Array(0) : (e = new Uint8Array(4 + a.byteLength), e[0] = 223, e[1] = 32, e[2] = a.byteLength >> 8, e[3] = a.byteLength, e.set(a,
                4));
            if (45 < e.byteLength + f.byteLength) return l = new GTIdemJs, l.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, r["return"](l);
            if (44 < f.byteLength) return h = new GTIdemJs, h.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, r["return"](h);
            g = f.byteLength + e.byteLength;
            q = Uint8Array.from(window.atob(GTheader), function (p) {
                return p.charCodeAt(0)
            });
            k = new Uint8Array(3);
            k[0] = 0 == b ? CMD_REQUESTP384CSR : CMD_REQUESTP384CSR_AFTER_CLEAR;
            k[1] = g >> 8;
            k[2] = g;
            m = _appendBuffer(q, k);
            m = _appendBuffer(m, e);
            m = _appendBuffer(m, f);
            n = {
                challenge: d,
                rp: {
                    name: "GoTrustID Inc."
                },
                user: {
                    id: m,
                    name: sUserName,
                    displayName: sUserName
                },
                authenticatorSelection: {
                    userVerification: "required",
                    requireResidentKey: !1,
                    residentKey: "discouraged",
                    authenticatorAttachment: "cross-platform"
                },
                timeout: VERIFY_DEFAULT_TIMEOUT,
                attestation: "direct",
                pubKeyCredParams: [{
                    type: "public-key",
                    alg: -7
                }, {
                    type: "public-key",
                    alg: -257
                }]
            };
            return r.yield(navigator.credentials.create({
                publicKey: n
            }).then(function (p) {
                p = CBOR.decode(p.response.attestationObject);
                p = parseAuthData(p.authData).credID;
                p = p.buffer.slice(p.byteOffset,
                    p.byteLength + p.byteOffset);
                var t = new GTIdemJs;
                t.parsePKIoverFIDOResponse(p, CMD_REQUESTP384CSR);
                return t
            })["catch"](function (p) {
                var t = new GTIdemJs;
                t.ConvertWebError(p.name, p.message);
                return t
            }), 2)
        }
        return r["return"](r.yieldResult)
    })
}

function GTIDEM_GenP521CSR(a, c, b) {
    b = void 0 === b ? !1 : b;
    var d, f, e, l, h, g, q, k, m, n;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (r) {
        if (1 == r.nextAddress) {
            d = new Uint8Array(32);
            window.crypto.getRandomValues(d);
            void 0 == c || 0 == c.byteLength ? f = new Uint8Array(0) : (f = new Uint8Array(4 + c.byteLength), f[0] = 223, f[1] = 38, f[2] = c.byteLength >> 8, f[3] = c.byteLength, f.set(c, 4));
            void 0 == a || 0 == a.byteLength ? e = new Uint8Array(0) : (e = new Uint8Array(4 + a.byteLength), e[0] = 223, e[1] = 32, e[2] = a.byteLength >> 8, e[3] = a.byteLength, e.set(a,
                4));
            if (45 < e.byteLength + f.byteLength) return l = new GTIdemJs, l.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, r["return"](l);
            if (44 < f.byteLength) return h = new GTIdemJs, h.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, r["return"](h);
            g = f.byteLength + e.byteLength;
            q = Uint8Array.from(window.atob(GTheader), function (p) {
                return p.charCodeAt(0)
            });
            k = new Uint8Array(3);
            k[0] = 0 == b ? CMD_REQUESTP521CSR : CMD_REQUESTP521CSR_AFTER_CLEAR;
            k[1] = g >> 8;
            k[2] = g;
            m = _appendBuffer(q, k);
            m = _appendBuffer(m, e);
            m = _appendBuffer(m, f);
            n = {
                challenge: d,
                rp: {
                    name: "GoTrustID Inc."
                },
                user: {
                    id: m,
                    name: sUserName,
                    displayName: sUserName
                },
                authenticatorSelection: {
                    userVerification: "required",
                    requireResidentKey: !1,
                    residentKey: "discouraged",
                    authenticatorAttachment: "cross-platform"
                },
                timeout: VERIFY_DEFAULT_TIMEOUT,
                attestation: "direct",
                pubKeyCredParams: [{
                    type: "public-key",
                    alg: -7
                }, {
                    type: "public-key",
                    alg: -257
                }]
            };
            return r.yield(navigator.credentials.create({
                publicKey: n
            }).then(function (p) {
                p = CBOR.decode(p.response.attestationObject);
                p = parseAuthData(p.authData).credID;
                p = p.buffer.slice(p.byteOffset,
                    p.byteLength + p.byteOffset);
                var t = new GTIdemJs;
                t.parsePKIoverFIDOResponse(p, CMD_REQUESTP521CSR);
                return t
            })["catch"](function (p) {
                var t = new GTIdemJs;
                t.ConvertWebError(p.name, p.message);
                return t
            }), 2)
        }
        return r["return"](r.yieldResult)
    })
}

function GTIDEM_GenRSA2048CSR(a, c, b) {
    b = void 0 === b ? !1 : b;
    var d, f, e, l, h, g, q, k, m, n;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (r) {
        if (1 == r.nextAddress) {
            d = new Uint8Array(32);
            window.crypto.getRandomValues(d);
            void 0 == c || 0 == c.byteLength ? f = new Uint8Array(0) : (f = new Uint8Array(4 + c.byteLength), f[0] = 223, f[1] = 38, f[2] = c.byteLength >> 8, f[3] = c.byteLength, f.set(c, 4));
            void 0 == a || 0 == a.byteLength ? e = new Uint8Array(0) : (e = new Uint8Array(4 + a.byteLength), e[0] = 223, e[1] = 32, e[2] = a.byteLength >> 8, e[3] = a.byteLength,
                e.set(a, 4));
            if (45 < e.byteLength + f.byteLength) return l = new GTIdemJs, l.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, r["return"](l);
            if (44 < f.byteLength) return h = new GTIdemJs, h.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, r["return"](h);
            g = f.byteLength + e.byteLength;
            q = Uint8Array.from(window.atob(GTheader), function (p) {
                return p.charCodeAt(0)
            });
            k = new Uint8Array(3);
            k[0] = 0 == b ? CMD_REQUESTCSR : CMD_REQUESTCSR_AFTER_CLEAR;
            k[1] = g >> 8;
            k[2] = g;
            m = _appendBuffer(q, k);
            m = _appendBuffer(m, e);
            m = _appendBuffer(m, f);
            n = {
                challenge: d,
                rp: {
                    name: "GoTrustID Inc."
                },
                user: {
                    id: m,
                    name: sUserName,
                    displayName: sUserName
                },
                authenticatorSelection: {
                    userVerification: "required",
                    requireResidentKey: !1,
                    residentKey: "discouraged",
                    authenticatorAttachment: "cross-platform"
                },
                timeout: VERIFY_DEFAULT_TIMEOUT,
                attestation: "direct",
                pubKeyCredParams: [{
                    type: "public-key",
                    alg: -7
                }, {
                    type: "public-key",
                    alg: -257
                }]
            };
            return r.yield(navigator.credentials.create({
                publicKey: n
            }).then(function (p) {
                p = CBOR.decode(p.response.attestationObject);
                p = parseAuthData(p.authData).credID;
                p = p.buffer.slice(p.byteOffset,
                    p.byteLength + p.byteOffset);
                var t = new GTIdemJs;
                t.parsePKIoverFIDOResponse(p, CMD_REQUESTCSR);
                return t
            })["catch"](function (p) {
                var t = new GTIdemJs;
                t.ConvertWebError(p.name, p.message);
                return t
            }), 2)
        }
        return r["return"](r.yieldResult)
    })
}

function GTIDEM_GenRSA2048(a, c, b) {
    b = void 0 === b ? !1 : b;
    var d, f, e, l, h, g, q, k;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (m) {
        return 1 == m.nextAddress ? (d = new Uint8Array(32), window.crypto.getRandomValues(d), void 0 == a || 0 == a.byteLength ? f = new Uint8Array(0) : (f = new Uint8Array(4 + a.byteLength), f[0] = 223, f[1] = 32, f[2] = a.byteLength >> 8, f[3] = a.byteLength, f.set(a, 4)), void 0 == c || 0 == c.byteLength ? e = new Uint8Array(0) : (e = new Uint8Array(4 + c.byteLength), e[0] = 223, e[1] = 24, e[2] = c.byteLength >> 8, e[3] = c.byteLength, e.set(c,
            4)), l = e.byteLength + f.byteLength, h = Uint8Array.from(window.atob(GTheader), function (n) {
            return n.charCodeAt(0)
        }), g = new Uint8Array(3), g[0] = 0 == b ? CMD_GenRsaKeyPair : CMD_GenRsaKeyPair_AFTER_CLEAR, g[1] = l >> 8, g[2] = l, q = _appendBuffer(h, g), q = _appendBuffer(q, f), q = _appendBuffer(q, e), k = {
            challenge: d,
            rp: {
                name: "GoTrustID Inc."
            },
            user: {
                id: q,
                name: sUserName,
                displayName: sUserName
            },
            authenticatorSelection: {
                userVerification: "required",
                requireResidentKey: !1,
                residentKey: "discouraged",
                authenticatorAttachment: "cross-platform"
            },
            timeout: VERIFY_DEFAULT_TIMEOUT,
            attestation: "direct",
            pubKeyCredParams: [{
                type: "public-key",
                alg: -7
            }, {
                type: "public-key",
                alg: -257
            }]
        }, m.yield(navigator.credentials.create({
            publicKey: k
        }).then(function (n) {
            n = CBOR.decode(n.response.attestationObject);
            n = parseAuthData(n.authData).credID;
            n = n.buffer.slice(n.byteOffset, n.byteLength + n.byteOffset);
            var r = new GTIdemJs;
            r.parsePKIoverFIDOResponse(n, CMD_GenRsaKeyPair);
            return r
        })["catch"](function (n) {
            var r = new GTIdemJs;
            r.ConvertWebError(n.name, n.message);
            return r
        }), 2)) : m["return"](m.yieldResult)
    })
}

function GTIDEM_ImportCertificate(a, c, b, d, f, e) {
    var l, h, g, q, k, m, n, r, p, t, u, v, w, z, G, B, H, D, A, E, x, y, F;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (C) {
        if (1 == C.nextAddress) {
            l = get_browser();
            if ("Safari" == l.name && 15 <= parseInt(l.major)) return C.yield(GTIDEM_ImportCertificate2(a, c, b, d, f, e), 5);
            h = b;
            g = c;
            q = d;
            k = 0;
            m = new Uint8Array(32);
            window.crypto.getRandomValues(m);
            void 0 == a || 0 == a.byteLength ? n = new Uint8Array(0) : (n = new Uint8Array(4 + a.byteLength), n[0] = 223, n[1] = 32, n[2] = a.byteLength >> 8, n[3] = a.byteLength,
                n.set(a, 4));
            k += n.byteLength;
            if (void 0 == g || 0 == g.byteLength || 20 < g.byteLength) return r = new GTIdemJs, r.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, C["return"](r);
            if (void 0 == h || 0 == h.byteLength) p = new Uint8Array(4 + g.byteLength), p[0] = 223, p[1] = 32, p[2] = g.byteLength >> 8, p[3] = g.byteLength, p.set(g, 4);
            else {
                if (20 < h.byteLength) return t = new GTIdemJs, t.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, C["return"](t);
                p = new Uint8Array(4 + h.length);
                p[0] = 223;
                p[1] = 24;
                p[2] = h.byteLength >> 8;
                p[3] = h.byteLength;
                p.set(h, 4)
            }
            k += p.byteLength;
            u = new Uint8Array(4 + g.length);
            u[0] = 223;
            u[1] = 25;
            u[2] = g.byteLength >> 8;
            u[3] = g.byteLength;
            u.set(g, 4);
            k += u.byteLength;
            if (void 0 == q || 0 == q.byteLength || 2048 < q.byteLength) return v = new GTIdemJs, v.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, C["return"](v);
            w = new Uint8Array(4 + q.length);
            w[0] = 223;
            w[1] = 23;
            w[2] = q.byteLength >> 8;
            w[3] = q.byteLength;
            w.set(q, 4);
            k += w.byteLength;
            if (void 0 == f || 0 == f.byteLength) z = new Uint8Array(0);
            else {
                if (32 < f.byteLength) return G = new GTIdemJs, G.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, C["return"](G);
                z = new Uint8Array(4 + f.byteLength);
                z[0] = 223;
                z[1] = 6;
                z[2] = f.length >> 8;
                z[3] = f.length;
                z.set(f, 4)
            }
            k += z.byteLength;
            if (void 0 == e || 0 == e.byteLength) B = new Uint8Array(0);
            else {
                if (300 < e.byteLength) return H = new GTIdemJs, H.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, C["return"](H);
                B = new Uint8Array(4 + e.byteLength);
                B[0] = 223;
                B[1] = 40;
                B[2] = e.byteLength >> 8;
                B[3] = e.byteLength;
                B.set(e, 4)
            }
            k += B.byteLength;
            if (2250 < B.byteLength + w.byteLength) return D = new GTIdemJs, D.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, C["return"](D);
            A = Uint8Array.from(window.atob(GTheader),
                function (I) {
                    return I.charCodeAt(0)
                });
            E = new Uint8Array(3);
            E[0] = CMD_ImportCertificate;
            E[1] = k >> 8;
            E[2] = k;
            x = _appendBuffer(A, E);
            x = _appendBuffer(x, n);
            x = _appendBuffer(x, p);
            x = _appendBuffer(x, u);
            x = _appendBuffer(x, w);
            x = _appendBuffer(x, z);
            x = _appendBuffer(x, B);
            y = {
                challenge: m,
                userVerification: "required",
                timeout: VERIFY_DEFAULT_TIMEOUT
            };
            F = [{
                id: x,
                type: "public-key",
                transports: AUTHENTICATOR_TRANSPORTS
            }];
            y.allowCredentials = F;
            return C.yield(navigator.credentials.get({
                publicKey: y
            }).then(function (I) {
                var J = new GTIdemJs;
                J.parsePKIoverFIDOResponse(I.response.signature, CMD_ImportCertificate);
                return J
            })["catch"](function (I) {
                var J = new GTIdemJs;
                J.ConvertWebError(I.name, I.message);
                return J
            }), 4)
        }
        return C["return"](C.yieldResult)
    })
}

function GTIDEM_ImportCertificate2(a, c, b, d, f, e) {
    var l, h, g, q, k, m, n, r, p, t, u, v, w, z, G, B, H, D, A, E;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (x) {
        if (1 == x.nextAddress) {
            l = b;
            h = c;
            g = d;
            q = 0;
            k = new Uint8Array(32);
            window.crypto.getRandomValues(k);
            void 0 == a || 0 == a.byteLength ? m = new Uint8Array(0) : (m = new Uint8Array(4 + a.byteLength), m[0] = 223, m[1] = 32, m[2] = a.byteLength >> 8, m[3] = a.byteLength, m.set(a, 4));
            q += m.byteLength;
            void 0 == l || 0 == l.byteLength ? (n = new Uint8Array(4 + h.byteLength), n[0] = 223, n[1] = 32, n[2] = h.byteLength >>
                8, n[3] = h.byteLength, n.set(h, 4)) : (n = new Uint8Array(4 + l.length), n[0] = 223, n[1] = 24, n[2] = l.byteLength >> 8, n[3] = l.byteLength, n.set(l, 4));
            q += n.byteLength;
            r = new Uint8Array(4 + h.length);
            r[0] = 223;
            r[1] = 25;
            r[2] = h.byteLength >> 8;
            r[3] = h.byteLength;
            r.set(h, 4);
            q += r.byteLength;
            if (void 0 == g || 0 == g.byteLength || 2048 < g.byteLength) return p = new GTIdemJs, p.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, x["return"](p);
            t = new Uint8Array(4 + g.length);
            t[0] = 223;
            t[1] = 23;
            t[2] = g.byteLength >> 8;
            t[3] = g.byteLength;
            t.set(g, 4);
            q += t.byteLength;
            void 0 ==
                f || 0 == f.byteLength ? u = new Uint8Array(0) : (u = new Uint8Array(4 + f.byteLength), u[0] = 223, u[1] = 6, u[2] = f.length >> 8, u[3] = f.length, u.set(f, 4));
            q += u.byteLength;
            if (void 0 == e || 0 == e.byteLength) v = new Uint8Array(0);
            else {
                if (300 < e.byteLength) return w = new GTIdemJs, w.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH, x["return"](w);
                v = new Uint8Array(4 + e.byteLength);
                v[0] = 223;
                v[1] = 40;
                v[2] = e.byteLength >> 8;
                v[3] = e.byteLength;
                v.set(e, 4)
            }
            q += v.byteLength;
            if (2200 < v.byteLength + t.byteLength) return z = new GTIdemJs, z.statusCode = SETTING_ERR_OVER_BUFFER_LENGTH,
                x["return"](z);
            G = Uint8Array.from(window.atob(GTheader), function (y) {
                return y.charCodeAt(0)
            });
            B = new Uint8Array(3);
            B[0] = CMD_ImportCertificate2;
            B[1] = 0;
            B[2] = 0;
            H = _appendBuffer(G, B);
            D = new Uint8Array(3);
            D[0] = CMD_ImportCertificate2;
            D[1] = q >> 8;
            D[2] = q;
            A = _appendBuffer(G, D);
            A = _appendBuffer(A, m);
            A = _appendBuffer(A, n);
            A = _appendBuffer(A, r);
            A = _appendBuffer(A, t);
            A = _appendBuffer(A, u);
            A = _appendBuffer(A, v);
            E = {
                challenge: k,
                rp: {
                    name: "GT"
                },
                user: {
                    id: H,
                    name: "",
                    displayName: ""
                },
                timeout: VERIFY_DEFAULT_TIMEOUT,
                authenticatorSelection: {
                    userVerification: "required",
                    requireResidentKey: !1,
                    residentKey: "discouraged",
                    authenticatorAttachment: "cross-platform"
                },
                excludeCredentials: [{
                    id: A,
                    type: "public-key"
                }],
                attestation: "direct",
                pubKeyCredParams: [{
                    type: "public-key",
                    alg: -7
                }]
            };
            return x.yield(navigator.credentials.create({
                publicKey: E
            }).then(function (y) {
                y = CBOR.decode(y.response.attestationObject);
                y = parseAuthData(y.authData).credID;
                y = y.buffer.slice(y.byteOffset, y.byteLength + y.byteOffset);
                var F = new GTIdemJs;
                F.parsePKIoverFIDOResponse(y, CMD_ImportCertificate);
                return F
            })["catch"](function (y) {
                var F =
                    new GTIdemJs;
                F.ConvertWebError(y.name, y.message);
                return F
            }), 2)
        }
        return x["return"](x.yieldResult)
    })
}

function GTIDEM_DeleteCertByLabel(a, c) {
    var b, d, f, e, l, h, g, q, k;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (m) {
        return 1 == m.nextAddress ? (b = new Uint8Array(32), window.crypto.getRandomValues(b), d = new Uint8Array(4 + a.length), d[0] = 223, d[1] = 1, d[2] = a.byteLength >> 8, d[3] = a.byteLength, d.set(a, 4), void 0 == c || 0 == c.byteLength ? f = new Uint8Array(0) : (f = new Uint8Array(4 + c.byteLength), f[0] = 223, f[1] = 32, f[2] = c.byteLength >> 8, f[3] = c.byteLength, f.set(c, 4)), e = d.byteLength + f.byteLength, l = Uint8Array.from(window.atob(GTheader),
            function (n) {
                return n.charCodeAt(0)
            }), h = new Uint8Array(3), h[0] = CMD_DELEE_CERT, h[1] = e >> 8, h[2] = e, g = _appendBuffer(l, h), g = _appendBuffer(g, f), g = _appendBuffer(g, d), q = {
            challenge: b,
            userVerification: "required",
            timeout: VERIFY_DEFAULT_TIMEOUT
        }, k = [{
            id: g,
            type: "public-key",
            transports: AUTHENTICATOR_TRANSPORTS
        }], q.allowCredentials = k, m.yield(navigator.credentials.get({
            publicKey: q
        }).then(function (n) {
            var r = new GTIdemJs;
            r.parsePKIoverFIDOResponse(n.response.signature, CMD_DELEE_CERT);
            return r
        })["catch"](function (n) {
            var r =
                new GTIdemJs;
            r.ConvertWebError(n.name, n.message);
            return r
        }), 2)) : m["return"](m.yieldResult)
    })
}

function GTIDEM_ClearToken(a) {
    var c, b, d, f, e, l, h, g;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (q) {
        return 1 == q.nextAddress ? (c = new Uint8Array(32), window.crypto.getRandomValues(c), void 0 == a || 0 == a.byteLength ? b = new Uint8Array(0) : (b = new Uint8Array(4 + a.byteLength), b[0] = 223, b[1] = 32, b[2] = a.byteLength >> 8, b[3] = a.byteLength, b.set(a, 4)), d = b.byteLength, f = Uint8Array.from(window.atob(GTheader), function (k) {
            return k.charCodeAt(0)
        }), e = new Uint8Array(3), e[0] = CMD_CLEAR_TOKEN, e[1] = d >> 8, e[2] = d, l = _appendBuffer(f,
            e), l = _appendBuffer(l, b), h = {
            challenge: c,
            userVerification: "required",
            timeout: VERIFY_DEFAULT_TIMEOUT
        }, g = [{
            id: l,
            type: "public-key",
            transports: AUTHENTICATOR_TRANSPORTS
        }], h.allowCredentials = g, q.yield(navigator.credentials.get({
            publicKey: h
        }).then(function (k) {
            var m = new GTIdemJs;
            m.parsePKIoverFIDOResponse(k.response.signature, CMD_CLEAR_TOKEN);
            return m
        })["catch"](function (k) {
            var m = new GTIdemJs;
            m.ConvertWebError(k.name, k.message);
            return m
        }), 2)) : q["return"](q.yieldResult)
    })
}

function GTIDEM_GetTokenInfo(a) {
    var c, b, d, f, e, l, h, g;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (q) {
        return 1 == q.nextAddress ? (c = [], void 0 == a || 0 == a.byteLength ? b = new Uint8Array(0) : (b = new Uint8Array(4 + a.byteLength), b[0] = 223, b[1] = 32, b[2] = a.byteLength >> 8, b[3] = a.byteLength, b.set(a, 4)), d = new Uint8Array(32), window.crypto.getRandomValues(d), f = b.byteLength, e = Uint8Array.from(window.atob(GTheader), function (k) {
            return k.charCodeAt(0)
        }), l = new Uint8Array(3), l[0] = CMD_TokenInfo, l[1] = f >> 8, l[2] = f, c = _appendBuffer(e,
            l), c = _appendBuffer(c, b), h = {
            challenge: d,
            userVerification: "discouraged",
            timeout: DEFAULT_TIMEOUT
        }, g = [{
            id: c,
            type: "public-key",
            transports: ["usb", "nfc"]
        }], h.allowCredentials = g, q.yield(navigator.credentials.get({
            publicKey: h
        }).then(function (k) {
            var m = new GTIdemJs;
            m.parsePKIoverFIDOResponse(k.response.signature, CMD_TokenInfo);
            return m
        })["catch"](function (k) {
            var m = new GTIdemJs;
            m.ConvertWebError(k.name, k.message);
            return m
        }), 2)) : q["return"](q.yieldResult)
    })
}

function GTIDEM_SignDataByIndex(a, c, b, d) {
    var f, e, l, h, g, q, k, m, n, r, p;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (t) {
        return 1 == t.nextAddress ? (f = [], void 0 == c || 0 == c.byteLength ? e = new Uint8Array(0) : (e = new Uint8Array(4 + c.byteLength), e[0] = 223, e[1] = 32, e[2] = c.byteLength >> 8, e[3] = c.byteLength, e.set(c, 4)), l = new Uint8Array(32), window.crypto.getRandomValues(l), h = Uint8Array.from(window.atob(GTheader), function (u) {
                return u.charCodeAt(0)
            }), g = new Uint8Array(3), q = new Uint8Array(5), q[0] = 223, q[1] = 2, q[2] =
            0, q[3] = 1, q[4] = a, k = new Uint8Array(5), k[0] = 223, k[1] = 3, k[2] = 0, k[3] = 1, k[4] = b, m = new Uint8Array(4 + d.byteLength), m[0] = 223, m[1] = 6, m[2] = d.length >> 8, m[3] = d.length, m.set(d, 4), n = e.byteLength + q.byteLength + k.byteLength + m.byteLength, g[0] = CMD_Sign, g[1] = n >> 8, g[2] = n, f = _appendBuffer(h, g), f = _appendBuffer(f, e), f = _appendBuffer(f, q), f = _appendBuffer(f, k), f = _appendBuffer(f, m), r = {
                challenge: l,
                userVerification: "required",
                timeout: VERIFY_DEFAULT_TIMEOUT
            }, p = [{
                id: f,
                type: "public-key",
                transports: AUTHENTICATOR_TRANSPORTS
            }], r.allowCredentials =
            p, t.yield(navigator.credentials.get({
                publicKey: r
            }).then(function (u) {
                var v = new GTIdemJs;
                v.parsePKIoverFIDOResponse(u.response.signature, CMD_Sign);
                return v
            })["catch"](function (u) {
                var v = new GTIdemJs;
                v.ConvertWebError(u.name, u.message);
                return v
            }), 2)) : t["return"](t.yieldResult)
    })
}

function GTIDEM_SignDataByLabel(a, c, b, d) {
    var f, e, l, h, g, q, k, m, n, r, p;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (t) {
        return 1 == t.nextAddress ? (f = [], e = new Uint8Array(32), window.crypto.getRandomValues(e), l = Uint8Array.from(window.atob(GTheader), function (u) {
                return u.charCodeAt(0)
            }), h = new Uint8Array(3), void 0 == c || 0 == c.byteLength ? g = new Uint8Array(0) : (g = new Uint8Array(4 + c.byteLength), g[0] = 223, g[1] = 32, g[2] = c.byteLength >> 8, g[3] = c.byteLength, g.set(c, 4)), q = new Uint8Array(a.byteLength + 4), q[0] = 223,
            q[1] = 1, q[2] = a.byteLength >> 8, q[3] = a.byteLength, q.set(a, 4), k = new Uint8Array(5), k[0] = 223, k[1] = 3, k[2] = 0, k[3] = 1, k[4] = b, m = new Uint8Array(4 + d.byteLength), m[0] = 223, m[1] = 6, m[2] = d.length >> 8, m[3] = d.length, m.set(d, 4), n = g.byteLength + q.byteLength + k.byteLength + m.byteLength, h[0] = CMD_Sign, h[1] = n >> 8, h[2] = n, f = _appendBuffer(l, h), f = _appendBuffer(f, g), f = _appendBuffer(f, q), f = _appendBuffer(f, k), f = _appendBuffer(f, m), r = {
                challenge: e,
                userVerification: "required",
                timeout: VERIFY_DEFAULT_TIMEOUT
            }, p = [{
                id: f,
                type: "public-key",
                transports: AUTHENTICATOR_TRANSPORTS
            }],
            r.allowCredentials = p, t.yield(navigator.credentials.get({
                publicKey: r
            }).then(function (u) {
                var v = new GTIdemJs;
                v.parsePKIoverFIDOResponse(u.response.signature, CMD_Sign);
                return v
            })["catch"](function (u) {
                var v = new GTIdemJs;
                v.ConvertWebError(u.name, u.message);
                return v
            }), 2)) : t["return"](t.yieldResult)
    })
}

function GTIDEM_ReadCertByIndexWithoutPIN(a, c) {
    var b, d, f, e, l, h, g, q, k;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (m) {
        return 1 == m.nextAddress ? (b = [], void 0 == c || 0 == c.byteLength ? d = new Uint8Array(0) : (d = new Uint8Array(4 + c.byteLength), d[0] = 223, d[1] = 32, d[2] = c.byteLength >> 8, d[3] = c.byteLength, d.set(c, 4)), f = new Uint8Array(32), window.crypto.getRandomValues(f), e = Uint8Array.from(window.atob(GTheader), function (n) {
                return n.charCodeAt(0)
            }), l = new Uint8Array(3), h = new Uint8Array(5), h[0] = 223, h[1] = 2, h[2] =
            0, h[3] = 1, h[4] = a, g = d.byteLength + h.byteLength, l[0] = CMD_ReadCertificate, l[1] = g >> 8, l[2] = g, b = _appendBuffer(e, l), b = _appendBuffer(b, d), b = _appendBuffer(b, h), q = {
                challenge: f,
                userVerification: "discouraged",
                timeout: DEFAULT_TIMEOUT
            }, k = [{
                id: b,
                type: "public-key",
                transports: AUTHENTICATOR_TRANSPORTS
            }], q.allowCredentials = k, m.yield(navigator.credentials.get({
                publicKey: q
            }).then(function (n) {
                var r = new GTIdemJs;
                r.parsePKIoverFIDOResponse(n.response.signature, CMD_ReadCertificate);
                return r
            })["catch"](function (n) {
                var r = new GTIdemJs;
                r.ConvertWebError(n.name, n.message);
                return r
            }), 2)) : m["return"](m.yieldResult)
    })
}

function GTIDEM_ReadCertByLabelWithoutPIN(a, c) {
    var b, d, f, e, l, h, g, q, k;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (m) {
        return 1 == m.nextAddress ? (b = [], d = new Uint8Array(32), window.crypto.getRandomValues(d), f = Uint8Array.from(window.atob(GTheader), function (n) {
                return n.charCodeAt(0)
            }), e = new Uint8Array(3), void 0 == c || 0 == c.byteLength ? l = new Uint8Array(0) : (l = new Uint8Array(4 + c.byteLength), l[0] = 223, l[1] = 32, l[2] = c.byteLength >> 8, l[3] = c.byteLength, l.set(c, 4)), h = new Uint8Array(a.byteLength + 4), h[0] = 223,
            h[1] = 1, h[2] = a.byteLength >> 8, h[3] = a.byteLength, h.set(a, 4), g = l.byteLength + h.byteLength, e[0] = CMD_ReadCertificate, e[1] = g >> 8, e[2] = g, b = _appendBuffer(f, e), b = _appendBuffer(b, l), b = _appendBuffer(b, h), q = {
                challenge: d,
                userVerification: "discouraged",
                timeout: DEFAULT_TIMEOUT
            }, k = [{
                id: b,
                type: "public-key",
                transports: AUTHENTICATOR_TRANSPORTS
            }], q.allowCredentials = k, m.yield(navigator.credentials.get({
                publicKey: q
            }).then(function (n) {
                var r = new GTIdemJs;
                r.parsePKIoverFIDOResponse(n.response.signature, CMD_ReadCertificate);
                return r
            })["catch"](function (n) {
                var r = new GTIdemJs;
                r.ConvertWebError(n.name, n.message);
                return r
            }), 2)) : m["return"](m.yieldResult)
    })
}

function GTIDEM_SetName(a) {
    sUserName = a
}

function GTIDEM_InitToken(a, c, b) {
    var d, f, e, l, h, g, q, k, m, n;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (r) {
        return 1 == r.nextAddress ? (d = [], void 0 == a || 0 == a.byteLength ? f = new Uint8Array(0) : (f = new Uint8Array(4 + a.byteLength), f[0] = 223, f[1] = 32, f[2] = a.byteLength >> 8, f[3] = a.byteLength, f.set(a, 4)), e = new Uint8Array(32), window.crypto.getRandomValues(e), l = new Uint8Array(4 + c.byteLength), l[0] = 223, l[1] = 33, l[2] = c.byteLength >> 8, l[3] = c.byteLength, l.set(new Uint8Array(c), 4), h = new Uint8Array(4 + b.byteLength),
            h[0] = 223, h[1] = 34, h[2] = b.byteLength >> 8, h[3] = b.byteLength, h.set(new Uint8Array(b), 4), g = f.byteLength + l.byteLength + h.byteLength, q = Uint8Array.from(window.atob(GTheader), function (p) {
                return p.charCodeAt(0)
            }), k = new Uint8Array(3), k[0] = CMD_INIT_TOKEN, k[1] = g >> 8, k[2] = g, d = _appendBuffer(q, k), d = _appendBuffer(d, f), d = _appendBuffer(d, l), d = _appendBuffer(d, h), m = {
                challenge: e,
                userVerification: "discouraged",
                timeout: DEFAULT_TIMEOUT
            }, n = [{
                id: d,
                type: "public-key",
                transports: AUTHENTICATOR_TRANSPORTS
            }], m.allowCredentials = n, r.yield(navigator.credentials.get({
                publicKey: m
            }).then(function (p) {
                var t =
                    new GTIdemJs;
                t.parsePKIoverFIDOResponse(p.response.signature, CMD_INIT_TOKEN);
                return t
            })["catch"](function (p) {
                var t = new GTIdemJs;
                t.ConvertWebError(p.name, p.message);
                return t
            }), 2)) : r["return"](r.yieldResult)
    })
}

function GTIDEM_UnlockPIN(a, c, b) {
    var d, f, e, l, h, g, q, k, m, n;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (r) {
        return 1 == r.nextAddress ? (d = [], void 0 == a || 0 == a.byteLength ? f = new Uint8Array(0) : (f = new Uint8Array(4 + a.byteLength), f[0] = 223, f[1] = 32, f[2] = a.byteLength >> 8, f[3] = a.byteLength, f.set(a, 4)), e = new Uint8Array(32), window.crypto.getRandomValues(e), l = new Uint8Array(4 + c.byteLength), l[0] = 223, l[1] = 33, l[2] = c.byteLength >> 8, l[3] = c.byteLength, l.set(new Uint8Array(c), 4), h = new Uint8Array(4 + b.byteLength),
            h[0] = 223, h[1] = 34, h[2] = b.byteLength >> 8, h[3] = b.byteLength, h.set(new Uint8Array(b), 4), g = f.byteLength + l.byteLength + h.byteLength, q = Uint8Array.from(window.atob(GTheader), function (p) {
                return p.charCodeAt(0)
            }), k = new Uint8Array(3), k[0] = CMD_UNLOCK_PIN, k[1] = g >> 8, k[2] = g, d = _appendBuffer(q, k), d = _appendBuffer(d, f), d = _appendBuffer(d, l), d = _appendBuffer(d, h), m = {
                challenge: e,
                userVerification: "discouraged",
                timeout: DEFAULT_TIMEOUT
            }, n = [{
                id: d,
                type: "public-key",
                transports: AUTHENTICATOR_TRANSPORTS
            }], m.allowCredentials = n, r.yield(navigator.credentials.get({
                publicKey: m
            }).then(function (p) {
                var t =
                    new GTIdemJs;
                t.parsePKIoverFIDOResponse(p.response.signature, CMD_UNLOCK_PIN);
                return t
            })["catch"](function (p) {
                var t = new GTIdemJs;
                t.ConvertWebError(p.name, p.message);
                return t
            }), 2)) : r["return"](r.yieldResult)
    })
}
var _appendBuffer = function (a, c) {
    var b = new Uint8Array(a.byteLength + c.byteLength);
    b.set(new Uint8Array(a), 0);
    b.set(new Uint8Array(c), a.byteLength);
    return b.buffer
};

function GTIDEM_GenKeyPair(a, c, b, d) {
    var f, e, l, h, g, q, k, m, n, r;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (p) {
        return 1 == p.nextAddress ? (f = new Uint8Array(32), window.crypto.getRandomValues(f), void 0 == a || 0 == a.byteLength ? e = new Uint8Array(0) : (e = new Uint8Array(4 + a.byteLength), e[0] = 223, e[1] = 32, e[2] = a.byteLength >> 8, e[3] = a.byteLength, e.set(a, 4)), void 0 == c || 0 == c.byteLength ? l = new Uint8Array(0) : (l = new Uint8Array(4 + c.byteLength), l[0] = 223, l[1] = 24, l[2] = c.byteLength >> 8, l[3] = c.byteLength, l.set(c, 4)), h =
            new Uint8Array(5), h[0] = 223, h[1] = 35, h[2] = 0, h[3] = 1, h[4] = b, g = new Uint8Array(5), g[0] = 223, g[1] = 36, g[2] = 0, g[3] = 1, g[4] = d, q = l.byteLength + e.byteLength + h.length + g.length, k = Uint8Array.from(window.atob(GTheader), function (t) {
                return t.charCodeAt(0)
            }), m = new Uint8Array(3), m[0] = CMD_GenKeyPair, m[1] = q >> 8, m[2] = q, n = _appendBuffer(k, m), n = _appendBuffer(n, e), n = _appendBuffer(n, l), n = _appendBuffer(n, h), n = _appendBuffer(n, g), r = {
                challenge: f,
                rp: {
                    name: "GoTrustID Inc."
                },
                user: {
                    id: n,
                    name: sUserName,
                    displayName: sUserName
                },
                timeout: VERIFY_DEFAULT_TIMEOUT,
                authenticatorSelection: {
                    userVerification: "required",
                    requireResidentKey: !1,
                    residentKey: "discouraged",
                    authenticatorAttachment: "cross-platform"
                },
                attestation: "direct",
                pubKeyCredParams: [{
                    type: "public-key",
                    alg: -7
                }, {
                    type: "public-key",
                    alg: -257
                }]
            }, p.yield(navigator.credentials.create({
                publicKey: r
            }).then(function (t) {
                t = CBOR.decode(t.response.attestationObject);
                t = parseAuthData(t.authData).credID;
                t = t.buffer.slice(t.byteOffset, t.byteLength + t.byteOffset);
                var u = new GTIdemJs;
                u.parsePKIoverFIDOResponse(t, CMD_GenKeyPair);
                return u
            })["catch"](function (t) {
                var u = new GTIdemJs;
                u.ConvertWebError(t.name, t.message);
                return u
            }), 2)) : p["return"](p.yieldResult)
    })
}

function GTIDEM_FactoryResetToken(a, c) {
    var b, d, f, e, l, h, g, q, k;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (m) {
        return 1 == m.nextAddress ? (b = [], void 0 == a || 0 == a.byteLength ? d = new Uint8Array(0) : (d = new Uint8Array(4 + a.byteLength), d[0] = 223, d[1] = 32, d[2] = a.byteLength >> 8, d[3] = a.byteLength, d.set(a, 4)), f = new Uint8Array(32), window.crypto.getRandomValues(f), e = new Uint8Array(4 + c.byteLength), e[0] = 223, e[1] = 37, e[2] = c.byteLength >> 8, e[3] = c.byteLength, e.set(new Uint8Array(c), 4), l = d.byteLength + e.byteLength,
            h = Uint8Array.from(window.atob(GTheader), function (n) {
                return n.charCodeAt(0)
            }), g = new Uint8Array(3), g[0] = CMD_FactoryReset, g[1] = l >> 8, g[2] = l, b = _appendBuffer(h, g), b = _appendBuffer(b, d), b = _appendBuffer(b, e), q = {
                challenge: f,
                userVerification: "discouraged",
                timeout: DEFAULT_TIMEOUT
            }, k = [{
                id: b,
                type: "public-key",
                transports: AUTHENTICATOR_TRANSPORTS
            }], q.allowCredentials = k, m.yield(navigator.credentials.get({
                publicKey: q
            }).then(function (n) {
                var r = new GTIdemJs;
                r.parsePKIoverFIDOResponse(n.response.signature, CMD_CHANGE_PIN);
                return r
            })["catch"](function (n) {
                var r = new GTIdemJs;
                r.ConvertWebError(n.name, n.message);
                return r
            }), 2)) : m["return"](m.yieldResult)
    })
}

function GTIDEM_GetJSVersion() {
    return VERSION
}

function GTIDEM_ReadCertExtraWithIndex(a, c) {
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (b) {
        return 1 == b.nextAddress ? b.yield(_GTIDEM_ReadCertExtras(void 0, a, c), 2) : b["return"](b.yieldResult)
    })
}

function GTIDEM_ReadCertExtraWithLabel(a, c) {
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (b) {
        return 1 == b.nextAddress ? b.yield(_GTIDEM_ReadCertExtras(a, void 0, c), 2) : b["return"](b.yieldResult)
    })
}

function GTIDEM_ReadAllCertExtra(a) {
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (c) {
        return 1 == c.nextAddress ? c.yield(_GTIDEM_ReadCertExtras(void 0, void 0, a), 2) : c["return"](c.yieldResult)
    })
}

function _GTIDEM_ReadCertExtras(a, c, b) {
    var d, f, e, l, h, g, q, k, m;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function (n) {
        return 1 == n.nextAddress ? (d = [], f = new Uint8Array(32), window.crypto.getRandomValues(f), e = Uint8Array.from(window.atob(GTheader), function (r) {
            return r.charCodeAt(0)
        }), l = new Uint8Array(3), void 0 == b || 0 == b.byteLength ? h = new Uint8Array(0) : (h = new Uint8Array(4 + b.byteLength), h[0] = 223, h[1] = 32, h[2] = b.byteLength >> 8, h[3] = b.byteLength, h.set(b, 4)), g = new Uint8Array(0), void 0 != a ? (g = new Uint8Array(a.byteLength +
            4), g[0] = 223, g[1] = 1, g[2] = a.byteLength >> 8, g[3] = a.byteLength, g.set(a, 4)) : void 0 != c && (g = new Uint8Array(5), g[0] = 223, g[1] = 2, g[2] = 0, g[3] = 1, g[4] = c), q = h.byteLength + g.byteLength, l[0] = CMD_GetCertExtras, l[1] = q >> 8, l[2] = q, d = _appendBuffer(e, l), d = _appendBuffer(d, h), d = _appendBuffer(d, g), k = {
            challenge: f,
            userVerification: "discouraged",
            timeout: DEFAULT_TIMEOUT
        }, m = [{
            id: d,
            type: "public-key",
            transports: AUTHENTICATOR_TRANSPORTS
        }], k.allowCredentials = m, n.yield(navigator.credentials.get({
            publicKey: k
        }).then(function (r) {
            var p = new GTIdemJs;
            p.parsePKIoverFIDOResponse(r.response.signature, CMD_GetCertExtras);
            return p
        })["catch"](function (r) {
            var p = new GTIdemJs;
            p.ConvertWebError(r.name, r.message);
            return p
        }), 2)) : n["return"](n.yieldResult)
    })
};