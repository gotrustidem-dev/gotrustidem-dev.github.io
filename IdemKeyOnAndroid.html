<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <!-- 设置视口以确保页面在移动设备上正确显示 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebAuthn Demo</title>
  <style>
    .form-control {
      width: 100%;
      /* 使输入框和按钮宽度填满容器 */
      margin-bottom: 10px;
      /* 添加一些底部间距 */
      box-sizing: border-box;
      /* 确保padding和border不会增加元素的宽度 */
    }

    .form-container {
      max-width: 400px;
      /* 或你希望的最大宽度 */
      margin: auto;
      /* 水平居中 */
      padding: 20px;
      /* 添加一些内边距 */
    }

    h2 {
      text-align: center;
    }

    #messageBox {
      height: 200px;
      /* 设置固定高度 */
      overflow-y: auto;
      /* 显示垂直滚动条 */
      border: 1px solid #ccc;
      /* 设置边框 */
      margin-top: 10px;
      /* 和上面的元素保持间距 */
      padding: 5px;
      /* 内边距 */
    }

    /* 消息之间的分隔线 */
    .message {
      border-bottom: 1px solid #eee;
      /* 设置分隔线 */
      padding: 5px 0;
      /* 设置消息的上下内边距 */
    }
  </style>
  <script src="utils/cbor.js"></script>
  <script src="utils/helpers.js"></script>
  <script src="utils/showMessage.js"></script>
  <script src="utils/PKIoverFIDO.js"></script>
  <script src="utils/jquery.min.js"></script>
  <script src="utils/bootstrap.min.js" integrity="sha256-Tz+u7EaSlLYQ9sqCqhzCszaP1WYRsxxVHC7iJP6ttBE="
    crossorigin="anonymous"></script>
  <script async="" src="lib/bundle.js"></script>

  <script src="utils/PKIoverFIDO.js"></script>

</head>

<body>

  <h2>WebAuthn Registration and Authentication</h2>

  <!-- 用户名输入框 -->


  <div class="form-container">
    <input type="text" id="username" name="username" placeholder="Username" class="form-control">
    <label>Register User Verification</label>
    <select id="reg_userVerification" class="select-control">
      <option value="preferred">Preferred</option>
      <option value="required">Required</option>
      <option value="discouraged">Discouraged</option>

    </select>
    <button id="register" type="button" onclick="register()" class="form-control">Register</button>
    <label>Authenticate User Verification</label>
    <select id="auth_userVerification" class="select-control">
      <option value="preferred">Preferred</option>
      <option value="required">Required</option>
      <option value="discouraged">Discouraged</option>
    </select>
    <button id="authenticate" type="button" onclick="authenticate()" class="form-control">Authenticate</button>
  </div>
  <div id="messageBox"></div>
  <script>
    window.addEventListener('load', () => {
      localStorage.clear();
      console.log('LocalStorage has been cleared.');
    });
    // 注册按钮事件监听
    document.getElementById('register').addEventListener('click', function () {
      // 这里添加调用注册函数的逻辑
      console.log('Register button clicked');
      const username = document.getElementById('username').value;
      var challengeByte = new Uint8Array(32);
      window.crypto.getRandomValues(challengeByte);
      var userid = new Uint8Array(32);
      window.crypto.getRandomValues(userid);
      const excludeCredentials = getCredentialsForUsername(username);
      const userVerificationValue = document.getElementById('reg_userVerification').value;
      const publicKey = {
        rp: {
          name: "webauthn.io"
        },
        user: {
          id: userid,
          name: username,
          displayName: username
        },
        challenge: challengeByte, // 替换为从服务器获得的挑战
        pubKeyCredParams: [{
            type: "public-key",
            alg: -7
          },
          {
            type: "public-key",
            alg: -257
          }
        ],
        authenticatorSelection: {
          authenticatorAttachment: "cross-platform",
          residentKey: "discouraged",
          requireResidentKey: false,
          userVerification: userVerificationValue
        },
        attestation: "none",
        timeout: 60000,
        excludeCredentials: excludeCredentials, // 使用从localStorage获取的数据
      };
      const userCredentialsJSON = localStorage.getItem(username);
      let publicKeyCopy = transformPublicKey(publicKey);
      // 将publicKey对象转换为易于阅读的字符串
      const message = "Register\n" + JSON.stringify(publicKeyCopy, null, 2);

      // 将消息添加到消息框中
      const messageBox = document.getElementById("messageBox");
      const newMessage = document.createElement("div");
      newMessage.classList.add("message");
      newMessage.textContent = message;
      messageBox.appendChild(newMessage);

      // 确保新消息可见（滚动到底部）
      messageBox.scrollTop = messageBox.scrollHeight;

      console.log('List publicKey', publicKey);
      navigator.credentials.create({
          'publicKey': publicKey
        })
        .then((newCredentialInfo) => {
          console.log('SUCCESS', newCredentialInfo)
          console.log('ClientDataJSON: ', arrayBufferToString(newCredentialInfo.response
            .clientDataJSON))
          let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
          console.log('AttestationObject: ', attestationObject)
          let authData = parseAuthData(attestationObject.authData);
          console.log('AuthData: ', authData);
          console.log('CredID: ', bufToHex(authData.credID));
          saveCredential(username, arrayBufferToBase64(authData.credID))
          console.log('AAGUID: ', bufToHex(authData.aaguid));
          console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));
          alert('Register complete!!!')
          const message = "Register complete!!!,Store " + username + " to LocalStorage";
          const newMessage = document.createElement("div");
          newMessage.classList.add("message");
          newMessage.textContent = message;
          messageBox.appendChild(newMessage);

          // 确保新消息可见（滚动到底部）
          messageBox.scrollTop = messageBox.scrollHeight;

        })
        .catch((error) => {
          alert(error)
          console.log('FAIL', error)
        })


    });

    // 验证按钮事件监听
    document.getElementById('authenticate').addEventListener('click', function () {
      // 这里添加调用验证函数的逻辑
      console.log('Authenticate button clicked');
      var challenge = new Uint8Array(32);
      const username = document.getElementById('username').value;
      window.crypto.getRandomValues(challenge);
      const allowCredentials = getCredentialsForUsername(username);
      const userVerificationValue = document.getElementById('auth_userVerification').value;
      const options = {
        challenge: challenge, // will be another value, provided by the relying party server
        userVerification: userVerificationValue,
        allowCredentials: allowCredentials
      };

      let optionsCopy = transformPublicKey(options);
      // 将publicKey对象转换为易于阅读的字符串
      const message = "Authenticate\n" + JSON.stringify(optionsCopy, null, 2);

      // 将消息添加到消息框中
      const messageBox = document.getElementById("messageBox");
      const newMessage = document.createElement("div");
      newMessage.classList.add("message");
      newMessage.textContent = message;
      messageBox.appendChild(newMessage);

      // 确保新消息可见（滚动到底部）
      messageBox.scrollTop = messageBox.scrollHeight;

      navigator.credentials.get({
          publicKey: options
        })
        .then((assertionPKCred) => {

          if (assertionPKCred.response) {
            const clientDataJSON = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(assertionPKCred
              .response.clientDataJSON)));
            console.log('Client Data JSON:', clientDataJSON);
            console.log('Authenticator Data:', assertionPKCred.response.authenticatorData);

            console.log('Signature:', assertionPKCred.response.signature);
            console.log('User Handle:', assertionPKCred.response.userHandle);
            var data = parseAuthenticatorData(assertionPKCred.response.authenticatorData);
            alert('Authentication complete!!!\n' + data)
            const message = "Authentication complete!!!\n'" + data;
            const newMessage = document.createElement("div");
            newMessage.classList.add("message");
            newMessage.textContent = message;
            messageBox.appendChild(newMessage);
            messageBox.scrollTop = messageBox.scrollHeight;
          }
        }).catch((error) => {
          alert(error)
          console.log('FAIL', error)
        });

    });

    async function hashUsernameToUserId(username) {
      const encoder = new TextEncoder();
      const data = encoder.encode(username);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      return new Uint8Array(hashBuffer);
    }

    function saveCredential(username, credentialID) {
      const credentials = JSON.parse(localStorage.getItem('webauthnCredentials') || '{}');
      credentials[username] = credentialID;
      localStorage.setItem('webauthnCredentials', JSON.stringify(credentials));
    }

    function getCredentialsForUsername(username) {
      const credentials = JSON.parse(localStorage.getItem('webauthnCredentials') || '{}');
      if (credentials[username]) {
        return [{
          id: base64ToArrayBuffer(credentials[username]), // 假设 credentialID 已经是 Base64 编码的
          type: "public-key",
          transports: ["idemkey"]
        }];
      }
      return [];
    }

    function arrayBufferToString(arrayBuffer) {
      return String.fromCharCode.apply(null, new Uint8Array(arrayBuffer));
    }

    function base64ToArrayBuffer(base64) {
      const binaryString = window.atob(base64); // 将Base64字符串解码为二进制字符串
      const len = binaryString.length;
      const bytes = new Uint8Array(len); // 创建与二进制字符串长度相等的Uint8Array

      for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i); // 将每个字符的char code转换为Uint8Array的元素
      }
      return bytes.buffer; // 返回Uint8Array的buffer属性，它是一个ArrayBuffer
    }

    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    }

    function parseAuthenticatorData(buffer) {
      const dataView = new DataView(buffer);
      const rpIdHash = buffer.slice(0, 32); // RP ID hash 占据前32个字节
      const flagsByte = dataView.getUint8(32); // 标志位在第32个字节
      const userPresent = (flagsByte & 0x01) === 0x01; // 用户出席标志位
      const userVerified = (flagsByte & 0x04) === 0x04; // 用户验证标志位
      const signCount = dataView.getUint32(33, false); // 签名计数器占据第33到36字节

      // 打印出解析结果
      console.log('RP ID Hash:', rpIdHash);
      console.log('User Present:', userPresent);
      console.log('User Verified:', userVerified);
      console.log('Sign Count:', signCount);

      let output = '';
      output += 'User Present: ' + userPresent + '\n';
      output += 'User Verified: ' + userVerified + '\n';
      output += 'Sign Count: ' + signCount;

      return output;
      // 此处省略了Attested Credential Data和Extensions的解析
    }

    function byteArrayToHexString(byteArray) {
      return Array.from(byteArray, byte => {
        return ('0' + (byte & 0xFF).toString(16)).slice(-2);
      }).join('');
    }

    function uint8ArrayToHexString2(uint8Array) {

      return Array.from(uint8Array, byte => ('0' + (byte & 0xFF).toString(16)).slice(-2)).join('');
    }

    function transformPublicKey(publicKey) {
      // 复制publicKey对象
      var newPublicKey = JSON.parse(JSON.stringify(publicKey));;
      //   if (typeof JSON.clone !== "function") {
      //     JSON.clone = function(obj) {
      //     return 
      //     };
      // }
      // 将Uint8Array转换为十六进制字符串
      //if (newPublicKey.challenge instanceof Uint8Array) {
      newPublicKey.challenge = byteArrayToHexString(publicKey.challenge);
      // }
      // if (newPublicKey.user.id instanceof Uint8Array) {
      if (typeof newPublicKey.user !== 'undefined') {
        newPublicKey.user.id = byteArrayToHexString(publicKey.user.id);
      }
      //}
      if (typeof newPublicKey.excludeCredentials !== 'undefined' && newPublicKey.excludeCredentials.length > 0) {
        // if (newPublicKey.excludeCredentials[0].id instanceof Uint8Array) {
        newPublicKey.excludeCredentials[0].id = byteArrayToHexString(new Uint8Array(publicKey.excludeCredentials[0]
          .id));
        //}
      }
      if (typeof newPublicKey.allowCredentials !== 'undefined' && newPublicKey.allowCredentials.length > 0) {
        // if (newPublicKey.allowCredentials[0].id instanceof Uint8Array) {
        newPublicKey.allowCredentials[0].id = byteArrayToHexString(new Uint8Array(publicKey.allowCredentials[0].id));
        //}
      }


      // 可以在这里继续转换其他可能存在的Uint8Array属性

      return newPublicKey;
    }
  </script>
</body>

</html>