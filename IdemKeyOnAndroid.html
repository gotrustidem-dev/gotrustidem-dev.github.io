<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <!-- 设置视口以确保页面在移动设备上正确显示 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebAuthn Demo</title>
  <style>
    .form-control {
      width: 100%;
      /* 使输入框和按钮宽度填满容器 */
      margin-bottom: 10px;
      /* 添加一些底部间距 */
      box-sizing: border-box;
      /* 确保padding和border不会增加元素的宽度 */
    }

    .form-container {
      max-width: 400px;
      /* 或你希望的最大宽度 */
      margin: auto;
      /* 水平居中 */
      padding: 20px;
      /* 添加一些内边距 */
    }
  </style>
  <script src="utils/cbor.js"></script>
  <script src="utils/helpers.js"></script>
  <script src="utils/showMessage.js"></script>
  <script src="utils/PKIoverFIDO.js"></script>
  <script src="utils/jquery.min.js"></script>
  <script src="utils/bootstrap.min.js" integrity="sha256-Tz+u7EaSlLYQ9sqCqhzCszaP1WYRsxxVHC7iJP6ttBE="
    crossorigin="anonymous"></script>
  <script async="" src="lib/bundle.js"></script>

  <script src="utils/PKIoverFIDO.js"></script>

</head>

<body>

  <h2>WebAuthn Registration and Authentication</h2>

  <!-- 用户名输入框 -->


  <div class="form-container">
    <input type="text" id="username" name="username" placeholder="Username" class="form-control">
    <label>Register User Verification</label>
    <select id="reg_userVerification" class="select-control">
      <option value="preferred">Preferred</option>
      <option value="required">Required</option>
      <option value="discouraged">Discouraged</option>

    </select>
    <button id="register" type="button" onclick="register()" class="form-control">Register</button>
    <label>Authenticate User Verification</label>
    <select id="auth_userVerification" class="select-control">
      <option value="preferred">Preferred</option>
      <option value="required">Required</option>
      <option value="discouraged">Discouraged</option>
    </select>
    <button id="authenticate" type="button" onclick="authenticate()" class="form-control">Authenticate</button>
  </div>
  <script>
    // 注册按钮事件监听
    document.getElementById('register').addEventListener('click', function () {
      // 这里添加调用注册函数的逻辑
      console.log('Register button clicked');
      const username = document.getElementById('username').value;
      var challenge = new Uint8Array(32);
      window.crypto.getRandomValues(challenge);
      var userid = new Uint8Array(64);
      window.crypto.getRandomValues(userid);
      const excludeCredentials = getExcludeCredentialsForUsername(username);
      const userVerificationValue = document.getElementById('reg_userVerification').value;
      const publicKey = {
        rp: {
          name: "webauthn.io"
        },
        user: {
          id: userid,
          name: username,
          displayName: username
        },
        challenge: challenge, // 替换为从服务器获得的挑战
        pubKeyCredParams: [{
            type: "public-key",
            alg: -7
          },
          {
            type: "public-key",
            alg: -257
          }
        ],
        authenticatorSelection: {
          authenticatorAttachment: "cross-platform",
          residentKey: "discouraged",
          requireResidentKey: false,
          userVerification: userVerificationValue
        },
        attestation: "none",
        timeout: 60000,
        excludeCredentials: excludeCredentials, // 使用从localStorage获取的数据
      };
      const userCredentialsJSON = localStorage.getItem(username);



      console.log('List publicKey', publicKey);
      navigator.credentials.create({
          'publicKey': publicKey
        })
        .then((newCredentialInfo) => {



          console.log('SUCCESS', newCredentialInfo)
          console.log('ClientDataJSON: ', arrayBufferToString(newCredentialInfo.response
            .clientDataJSON))
          let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
          console.log('AttestationObject: ', attestationObject)
          let authData = parseAuthData(attestationObject.authData);
          console.log('AuthData: ', authData);
          console.log('CredID: ', bufToHex(authData.credID));
          saveCredential(username, arrayBufferToBase64(authData.credID))
          console.log('AAGUID: ', bufToHex(authData.aaguid));
          console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));
          alert('Register complete!!!')
        })
        .catch((error) => {
          alert(error)
          console.log('FAIL', error)
        })


    });

    // 验证按钮事件监听
    document.getElementById('authenticate').addEventListener('click', function () {
      // 这里添加调用验证函数的逻辑
      console.log('Authenticate button clicked');
      var challenge = new Uint8Array(32);
      const username = document.getElementById('username').value;
      window.crypto.getRandomValues(challenge);
      const allowCredentials = getExcludeCredentialsForUsername(username);
      const userVerificationValue = document.getElementById('auth_userVerification').value;
      const options = {
        challenge: challenge, // will be another value, provided by the relying party server
        userVerification: userVerificationValue,
        allowCredentials: allowCredentials
      };
      navigator.credentials.get({
          publicKey: options
        })
        .then((assertionPKCred) => {

          if (assertionPKCred.response) {
            const clientDataJSON = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(assertionPKCred
              .response.clientDataJSON)));
            console.log('Client Data JSON:', clientDataJSON);
            console.log('Authenticator Data:', assertionPKCred.response.authenticatorData);

            console.log('Signature:', assertionPKCred.response.signature);
            console.log('User Handle:', assertionPKCred.response.userHandle);
            var data = parseAuthenticatorData(assertionPKCred.response.authenticatorData);
            alert('Authentication complete!!!\n' + data)
          }
        }).catch((error) => {
          alert(error)
          console.log('FAIL', error)
        });

    });

    async function hashUsernameToUserId(username) {
      const encoder = new TextEncoder();
      const data = encoder.encode(username);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      return new Uint8Array(hashBuffer);
    }

    function saveCredential(username, credentialID) {
      const credentials = JSON.parse(localStorage.getItem('webauthnCredentials') || '{}');
      credentials[username] = credentialID;
      localStorage.setItem('webauthnCredentials', JSON.stringify(credentials));
    }

    function getExcludeCredentialsForUsername(username) {
      const credentials = JSON.parse(localStorage.getItem('webauthnCredentials') || '{}');
      if (credentials[username]) {
        return [{
          id: base64ToArrayBuffer(credentials[username]), // 假设 credentialID 已经是 Base64 编码的
          type: "public-key",
          transports: ["ubs"]
        }];
      }
      return [];
    }

    function arrayBufferToString(arrayBuffer) {
      return String.fromCharCode.apply(null, new Uint8Array(arrayBuffer));
    }

    function base64ToArrayBuffer(base64) {
      const binaryString = window.atob(base64); // 将Base64字符串解码为二进制字符串
      const len = binaryString.length;
      const bytes = new Uint8Array(len); // 创建与二进制字符串长度相等的Uint8Array

      for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i); // 将每个字符的char code转换为Uint8Array的元素
      }
      return bytes.buffer; // 返回Uint8Array的buffer属性，它是一个ArrayBuffer
    }

    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    }

    function parseAuthenticatorData(buffer) {
      const dataView = new DataView(buffer);
      const rpIdHash = buffer.slice(0, 32); // RP ID hash 占据前32个字节
      const flagsByte = dataView.getUint8(32); // 标志位在第32个字节
      const userPresent = (flagsByte & 0x01) === 0x01; // 用户出席标志位
      const userVerified = (flagsByte & 0x04) === 0x04; // 用户验证标志位
      const signCount = dataView.getUint32(33, false); // 签名计数器占据第33到36字节

      // 打印出解析结果
      console.log('RP ID Hash:', rpIdHash);
      console.log('User Present:', userPresent);
      console.log('User Verified:', userVerified);
      console.log('Sign Count:', signCount);

      let output = '';
      output += 'User Present: ' + userPresent + '\n';
      output += 'User Verified: ' + userVerified + '\n';
      output += 'Sign Count: ' + signCount;

      return output;
      // 此处省略了Attested Credential Data和Extensions的解析
    }

    function byteArrayToHexString(byteArray) {
      return Array.from(byteArray, byte => {
        return ('0' + (byte & 0xFF).toString(16)).slice(-2);
      }).join('');
    }
  </script>
</body>

</html>