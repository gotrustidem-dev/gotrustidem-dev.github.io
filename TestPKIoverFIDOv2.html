<!DOCTYPE html>
<html>

<head>
    <title>GoTrustIdem TestPKI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Ensure use of most common Unicode characters -->
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <!-- Considered an "experimental" feature -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css" />
    <!-- Spectre.css icons are used -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <script src="./utils/cbor.js"></script>
    <script src="./utils/helpers.js"></script>
    <script src="./utils/showMessage.js"></script>
    <script src="./utils/PKIoverFIDO.js"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'UA-3776848-14');
    </script>
    <script>
        (function (d) {
            var wf = d.createElement('script'),
                s = d.scripts[0];
            wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js';
            wf.async = true;
            s.parentNode.insertBefore(wf, s);
        })(document);
    </script>
    <script src="./library/jquery.min.js"></script>
    <script src="./library/bootstrap.min.js" integrity="sha256-Tz+u7EaSlLYQ9sqCqhzCszaP1WYRsxxVHC7iJP6ttBE="
        crossorigin="anonymous"></script>
    <script async="" src="./library/bundle.js"></script>
    <script>
        function displayCert(strCertificate) {

            $('#certificate').text(strCertificate)
            window.setTimeout(function () {
                console.log("Timeout ... trigger decode");
                $("#decode .btn").click();
            }, 100);


        }



        $(document).ready(function () {

            var pctd = document.getElementById('pc-td');
            var androidtd = document.getElementById('android-td');
            var safaritd = document.getElementById('safari-td');
            var macsafaritd = document.getElementById('mac-safari-td');

            var WhatSystem = navigator.userAgent;
            console.log(WhatSystem);
            if (WhatSystem.match("Android")) {
                console.log("This is android");
                pctd.style.display = 'none';
                safaritd.style.display = 'none';
                macsafaritd.style.display = 'none';
            } else if (WhatSystem.match("Windows")) {
                safaritd.style.display = 'none';
                androidtd.style.display = 'none';
                macsafaritd.style.display = 'none';
            } else if (WhatSystem.match("Safari")) {

                if (WhatSystem.match("Chrome")) {
                    safaritd.style.display = 'none';
                    androidtd.style.display = 'none';
                    macsafaritd.style.display = 'none';
                } else if (WhatSystem.match("Mac OS X") && WhatSystem.match("Version/14")) {
                    safaritd.style.display = 'none';
                    androidtd.style.display = 'none';
                    macsafaritd.style.display = 'none';
                } else {
                    pctd.style.display = 'none';
                    androidtd.style.display = 'none';
                    macsafaritd.style.display = 'none';
                }

            }


            var btnDecode = document.getElementById('decode');
            btnDecode.style.visibility = 'hidden';

            var ctrlErr = document.getElementById('upload-error');
            ctrlErr.style.visibility = 'hidden';

            var ctrlCert = document.getElementById('certificate');
            ctrlCert.style.visibility = 'hidden';

            var formcert = document.getElementById('form');
            formcert.style.visibility = 'hidden';
        });
    </script>
    <style>
        table.center {
            margin-left: auto;
            margin-right: auto;
            height: 160px;
        }

        table td,
        table td * {
            vertical-align: top;
        }

        h3 {
            text-align: center;
        }
    </style>
</head>

<body>
    <img style=" width: 100%; height: 100%;" src="./IdemHeader.png" alt="Idem Key icon " height="476" />
    <div style="overflow-x: scroll;">
        <table style="height: auto; width: 100%;">
            <tbody>
                <tr>
                    <td id="pc-td" style="width: 100% ; ">
                        <table class="center" border="1" width="395">
                            <tbody>

                                <tr>
                                    <!--PC side-->
                                    <td style="width: 385px;">
                                        <p style="text-align: center;">Operate by CKA_LABEL</p>

                                        <p>
                                            <form style="text-align: center;" id="use-label" onsubmit="return false">
                                                <input type="text" name="ckaLabel" style="width: 342px; height:41px">

                                            </form>
                                        </p>
                                        <form style="text-align: center;" id="search-ckalabel" onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                Certificate</button>
                                        </form>
                                        <p>
                                            <form style="text-align: center;" id="sign-byckalabel"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>


                                    <td style="width: 385px;">
                                        <p style="text-align: center;">Operate by Index (1~8)</p>
                                        <p>
                                            <form style="text-align:center" id="use-index" onsubmit="return false">
                                                <input type="number" name="certIndex" style="width: 342px; height:41px">
                                            </form>
                                        </p>
                                        <form style="text-align: center;" id="find-index" onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                Certificate</button>
                                        </form>
                                        <p>
                                            <form style="text-align: center;" id="sign-byindex" onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>

                                    <td style="width: 385px;">
                                        <p style="text-align: center;">Regisitration </p>
                                        <p>
                                            <form style="text-align: center;" id="btn_gen_rsakeypair"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Gen RSA
                                                    Key Pair</button>

                                                <p>
                                                    <label id="key_handle_value">Key Handle:</label>
                                                    <label id="target_key_handle"></label>
                                                </p>
                                            </form>
                                            <form style="text-align: center;" id="btn_sign_csr" onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign a
                                                    CRS</button>
                                            </form>
                                            <form style="text-align: center;" id="btn_import_certificate"
                                                onsubmit="return false">
                                                <p>
                                                    <label id="key_id_value">Key ID:</label><br>
                                                    <input type="text" id="target_key_id" style="width: 342px; height:41px">
                                                    <!--<label id="target_key_id">ffbbccddeeaa99887766554433221100</label>-->
                                                </p>
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Import
                                                    Cert. to Key</button>

                                            </form>
                                        </p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>

                    <td id="android-td" style="width: 329px;">

                        <table style="height: 160px;" border="1" width="395">
                            <tbody>
                                <tr>
                                    <td style="width: 385px; height: 233px; vertical-align:top">
                                        <p style="text-align: center;">Operate by CKA_LABEL</p>

                                        <p>
                                            <form style="text-align: center;" id="android-label"
                                                onsubmit="return false">
                                                <input type="text" name="ckaLabel" style="width: 342px; height:41px">
                                            </form>
                                        </p>

                                        <p>
                                            <form style="text-align: center;" id="android-ckalabel-getassertion"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>
                                </tr>

                                <tr>
                                    <td style="width: 385px; height: 233px; vertical-align:top">
                                        <p style="text-align: center;">Operate by Index (1~8)</p>

                                        <p>
                                            <form style="text-align: center;" id="android-index"
                                                onsubmit="return false">
                                                <input type="number" name="certIndex" style="width: 342px; height:41px">
                                            </form>
                                        </p>

                                        <p>
                                            <form style="text-align: center;" id="android-index-getassertion"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                    <td id="safari-td" style="width: 329px; ">

                        <table style="height: 160px;" border="1" width="395">
                            <tbody>
                                <tr>
                                    <td style="width: 385px; ">
                                        <p style="text-align: center;">Operate by CKA_LABEL</p>

                                        <p>
                                            <form style="text-align: center;" id="use-label-safari"
                                                onsubmit="return false">
                                                <input type="text" name="ckaLabel" style="width: 342px; height:41px">

                                            </form>
                                        </p>


                                        <form style="text-align: center;" id="search-ckalabel-safari"
                                            onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                Certificate</button>
                                        </form>
                                        <p>
                                            <form style="text-align: center;" id="sign-ckalabel-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>

                                </tr>
                                <tr>
                                    <td style="width: 385px;">
                                        <p style="text-align: center;">Operate Certificate by Index (1~8)</p>
                                        <p>
                                            <form style="text-align:center" id="use-index-safari"
                                                onsubmit="return false">
                                                <input type="number" name="certIndex" style="width: 342px; height:41px">
                                            </form>
                                        </p>
                                        <p>
                                            <form style="text-align: center;" id="find-index-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                    Certificate</button>
                                            </form>
                                        </p>

                                        <p>
                                            <form style="text-align: center;" id="sign-index-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>
                                </tr>


                            </tbody>
                        </table>
                    </td>

                    <td id="mac-safari-td" style="width: 329px; ">

                        <table class="center" style="height: 160px;" border="1" width="395">
                            <tbody>
                                <tr>
                                    <td style="width: 385px; ">
                                        <p style="text-align: center;">Operate by CKA_LABEL</p>

                                        <p>
                                            <form style="text-align: center;" id="use-label-safari"
                                                onsubmit="return false">
                                                <input type="text" name="ckaLabel" style="width: 342px; height:41px">

                                            </form>
                                        </p>


                                        <form style="text-align: center;" id="search-ckalabel-safari"
                                            onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                Certificate</button>
                                        </form>
                                        <p>
                                            <form style="text-align: center;" id="sign-ckalabel-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>
                                    <td style="width: 385px;">
                                        <p style="text-align: center;">Operate Certificate by Index (1~8)</p>
                                        <p>
                                            <form style="text-align:center" id="use-index-safari"
                                                onsubmit="return false">
                                                <input type="number" name="certIndex" style="width: 342px; height:41px">
                                            </form>
                                        </p>
                                        <p>
                                            <form style="text-align: center;" id="find-index-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                    Certificate</button>
                                            </form>
                                        </p>

                                        <p>
                                            <form style="text-align: center;" id="sign-index-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>

                </tr>
            </tbody>
        </table>
    </div>


    <!--  Laurence -->
    <div class="container mt-2">
        <div id="form" class="mt-2 mb-2">
            <div class="container">
                <div class="row">
                    <div class="col">
                        <div class="card">
                            <div class="card-body">
                                <div id="results" class="d-none mt-2"></div>
                                <form>
                                    <div class="form-group">
                                        <textarea class="form-control certificate" id="certificate" rows="8"
                                            style="white-space: pre" required="" autofocus=""></textarea>

                                        <div id="upload-error" class="alert alert-danger alert-dismissible mt-1"
                                            style="display: none;" role="alert">
                                            <small id="upload-error-message"></small>
                                            <button type="button" class="close" aria-label="Close"
                                                onclick="$(&#39;#upload-error&#39;).hide()">
                                                <span aria-hidden="true">×</span></button></div>
                                    </div>
                                    <div class="text-center">
                                        <div id="decode">
                                            <button id="decode" type="submit"
                                                class="btn btn-primary btn-lg">Decode</button>
                                        </div>
                                        <div id="error" class="alert alert-danger alert-dismissible mt-2"
                                            style="display: none;" role="alert">
                                            <span id="error-message"></span>
                                            <button type="button" class="close" aria-label="Close"
                                                onclick="$(&#39;#error&#39;).hide()">
                                                <span aria-hidden="true">×</span></button>
                                        </div>
                                    </div>

                                    <div id="cert-info-warn" class="alert alert-warning mt-3">
                                        <small>Certificate information will never leave your browser. Decoding happens
                                            using client-side JavaScript.</small>
                                    </div>
                                </form>

                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Command Header GoTrust-Idem-PKI
        var GTheader = 'R29UcnVzdC1JZGVtLVBLSQ==';

        // signed Data1: 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef  
        var signData =
            'MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWY=';


        //  signed Data2:  1234567890abcdef1234567890abcdef
        var signShortData = 'MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWY=';

        var testCertificate =
            'MIIDHjCCAgagAwIBAgIEG0BT9zANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNZdWJpY28gVTJGIFJvb3QgQ0EgU2VyaWFsIDQ1NzIwMDYzMTAgFw0xNDA4MDEwMDAwMDBaGA8yMDUwMDkwNDAwMDAwMFowLjEsMCoGA1UEAxMjWXViaWNvIFUyRiBSb290IENBIFNlcmlhbCA0NTcyMDA2MzEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC/jwYuhBVlqaiYWEMsrWFisgJ+PtM91eSrpI4TK7U53mwCIawSDHy8vUmk5N2KAj9abvT9NP5SMS1hQi3usxoYGonXQgfO6ZXyUA9a+KAkqdFnBnlyugSeCOep8EdZFfsaRFtMjkwz5Gcz2Py4vIYvCdMHPtwaz0bVuzneueIEz6TnQjE63Rdt2zbwnebwTG5ZybeWSwbzy+BJ34ZHcUhPAY89yJQXuE0IzMZFcEBbPNRbWECRKgjq//qT9nmDOFVlSRCt2wiqPSzluwn+v+suQEBsUjTGMEd25tKXXTkNW21wIWbxeSyUoTXwLvGS6xlwQSgNpk2qXYwf8iXg7VWZAgMBAAGjQjBAMB0GA1UdDgQWBBQgIvz0bNGJhjgpToksyKpP9xv9oDAPBgNVHRMECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAQEAjvjuOMDSa+JXFCLyBKsycXtBVZsJ4Ue3LbaEsPY4MYN/hIQ5ZM5p7EjfcnMG4CtYkNsfNHc0AhBLdq45rnT87q/6O3vUEtNMafbhU6kthX7Y+9XFN9NpmYxr+ekVY5xOxi8h9JDIgoMP4VB1uS0aunL1IGqrNooL9mmFnL2kLVVee6/VR6C5+KSTCMCWppMuJIZII2v9o4dkoZ8Y7QRjQlLfYzd3qGtKbw7xaF1UsG/5xUb/Btwb2X2g4InpiB/yt/3CpQXpiWX/K4mBvUKiGn05ZsqeY1gx4g0xLBqcU9psmyPzK+Vsgw2jeRQ5JlKDyqE0hebfC1tvFu0CCrJFcw==';

        document.getElementById('find-index').addEventListener('submit', function (event) {
            event.preventDefault();
            let certIndex = document.getElementById('use-index').certIndex.value;
            ReadCertByIndex(certIndex).then((value)=>{

                var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, value)) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)
                    displayCert(strCert)


            });
        })

        document.getElementById('find-index-safari').addEventListener('submit', function (event) {
            event.preventDefault();

            let certIndex = document.getElementById('use-index-safari').certIndex.value;
            ReadCertByIndex(certIndex).then((value)=>{

                var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(value) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)
                    displayCert(strCert)


            });
        })

        document.getElementById('sign-byindex').addEventListener('submit', function (event) {
            event.preventDefault();
            var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
            let certIndex = document.getElementById('use-index').certIndex.value;
            SignDataByIndex(certIndex,0x02,signDataPayload).then((value)=>{

                showSignMessage(value);

            });



        })

        document.getElementById('sign-byckalabel').addEventListener('submit', function (event) {
            event.preventDefault();
            var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
            let ckaLabel = document.getElementById('use-label').ckaLabel.value;
            SignDataByLabel(ckaLabel,0x02,signDataPayload).then((value)=>{
                showSignMessage(value);
            });
        })
       


        
        document.getElementById('search-ckalabel').addEventListener('submit', function (event) {
            event.preventDefault();
            let ckaLabel = document.getElementById('use-label').ckaLabel.value;
            ReadCertByLable(ckaLabel).then((value)=>{

            var strCert = "-----BEGIN CERTIFICATE-----\n" +
                    btoa(String.fromCharCode.apply(null, value)) +
                    "\n-----END CERTIFICATE-----"
                console.log('Certificatie : \n', strCert)
                displayCert(strCert)
            });

        })

        document.getElementById('search-ckalabel-safari').addEventListener('submit', function (event) {
            event.preventDefault();
            var pki_buffer = [];
            let ckaLabel = document.getElementById('use-label-safari').ckaLabel.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 4);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length >> 8;
            command_bufer[3] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 4);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Label'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "userVerification": "discouraged",
                    "authenticatorAttachment": "cross-platform",


                },
                'attestation': "none",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('search-ckalabel-safari', bufToHex(publicKey1));


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject);
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));


                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, new Uint8Array(authData.credID.slice(1,
                            authData.credID.length)))) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)



                    displayCert(strCert)




                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })

        
        document.getElementById('android-ckalabel-getassertion').addEventListener('submit', function (event) {
            event.preventDefault();




            let ckaLabel = document.getElementById('android-label').ckaLabel.value;
            //let userpin = document.getElementById('android-ckalabel-pin').pin.value;

            var userpin = prompt("Input your PIN", "");
            if (userpin == null) {
                return;
            }
            console.log('android-label', ckaLabel);
            console.log('android-ckalabel-pin', userpin);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 4);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length >> 8;
            command_bufer[3] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 4);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);


                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                var local_publicKey = key.publicKey;
                var local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(ckaLabel.length + 4);
                command_buf[0] = 0xDF
                command_buf[1] = 0x01;
                command_buf[2] = ckaLabel.length >> 8;
                command_buf[3] = ckaLabel.length;
                command_buf.set(toUTF8Array(ckaLabel), 4);



                var alg_buf = new Uint8Array(5);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 00;
                alg_buf[3] = 01;
                alg_buf[4] = 0x02;


                var ecpubkey_buf = new Uint8Array(4 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength >> 8;
                ecpubkey_buf[3] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 4);


                var encryptedPIN_buf = new Uint8Array(4 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength >> 8;
                encryptedPIN_buf[3] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 4);

                var signDataPayload = Uint8Array.from(window.atob(signShortData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(4 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length >> 8;
                signDataBuf[3] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 4);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE4;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-ckalabel-android: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                }).then((newCredentialInfo) => {

                    const sign1 = newCredentialInfo.response.signature;
                    if (sign1.byteLength < 251) {

                        var challenge = new Uint8Array(32);
                        window.crypto.getRandomValues(challenge);

                        var userID = 'Kosv9fPtkDoh4Oz7Yq/pVgWHS8HhdlCto5cR0aBoVMw='
                        var id = Uint8Array.from(window.atob(userID), c => c.charCodeAt(0))

                        var android_getSignature = {
                            'challenge': challenge,

                            'rp': {
                                'name': 'GoTrustID Inc.'
                            },

                            'user': {
                                'id': id,
                                'name': 'FastCar@example.com',
                                'displayName': 'Car man'
                            },

                            "authenticatorSelection": {
                                "userVerification": "discouraged",
                                'authenticatorAttachment': "cross-platform",
                            },

                            'pubKeyCredParams': [{
                                    'type': 'public-key',
                                    'alg': -7
                                },
                                {
                                    'type': 'public-key',
                                    'alg': -257
                                }
                            ]
                        }

                        console.log('Get reponse  android', android_getSignature)
                        navigator.credentials.create({
                                'publicKey': android_getSignature
                            }).then((newCredentialInfo) => {


                                let attestationObject = CBOR.decode(newCredentialInfo
                                    .response.attestationObject);
                                let authData = parseAuthData(attestationObject.authData);
                                var CredID = authData.credID;
                                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                                var externalECPublicKeyX = Object.values(publicKEy)[3];
                                console.log(bufToHex(externalECPublicKeyX));
                                var sig_buffer = new Uint8Array(256);
                                sig_buffer[0] = externalECPublicKeyX[0];
                                sig_buffer.set(new Uint8Array(CredID), 1);
                                console.log('Signature:', bufToHex(sig_buffer));
                                var str = String.fromCharCode.apply(null, new Uint8Array(
                                    sig_buffer));
                                alert("Plaintext:" + "\n" + signShortData +
                                    "\n" +
                                    "\n" +
                                    "Signature:" + "\n" + btoa(str));

                            })
                            .catch((error) => {
                                alert(error)
                                console.log('FAIL', error)
                            })
                    } else {

                        console.log('SUCCESS', newCredentialInfo);
                        console.log("Sign", newCredentialInfo.response.signature);
                        const sign1 = newCredentialInfo.response.signature;


                        var str = String.fromCharCode.apply(null, new Uint8Array(
                            sign1));
                        alert("Plaintext:" + "\n" + signShortData +
                            "\n" +
                            "\n" +
                            "Signature:" + "\n" + btoa(str));
                    }
                });

            });
        })
        
        document.getElementById('android-index-getassertion').addEventListener('submit', function (event) {
            event.preventDefault();


            let certIndex = document.getElementById('android-index').certIndex.value;
            var userpin;


            console.log('android-index', certIndex);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(5);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 0;
            command_bufer[3] = 01;
            command_bufer[4] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var android_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key request', android_readecdh);

            navigator.credentials.create({
                'publicKey': android_readecdh
            }).then((newCredentialInfo) => {
                userpin = prompt("Input your PIN", "");
                if (userpin == null) {
                    return;
                }
                console.log('android-index-pin', userpin);

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                //console.log("externalECPublicKeyX ", externalECPublicKeyX);
                //console.log("externalECPublicKeyY", externalECPublicKeyY);
                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(5);
                command_buf[0] = 0xDF;
                command_buf[1] = 0x02;
                command_buf[2] = 0;
                command_buf[3] = 01;
                command_buf[4] = certIndex;

                var alg_buf = new Uint8Array(5);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 0;
                alg_buf[3] = 01;
                alg_buf[4] = 0x02;


                var ecpubkey_buf = new Uint8Array(4 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength >> 8;
                ecpubkey_buf[3] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 4);


                var encryptedPIN_buf = new Uint8Array(4 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength >> 8;
                encryptedPIN_buf[3] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 4);

                var signDataPayload = Uint8Array.from(window.atob(signShortData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(4 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length >> 8;
                signDataBuf[3] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 4);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf
                    .byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-index-android-command: " + bufToHex(pki_buffer));
                console.log("sign-index-android-data: " + bufToHex(signDataBuf));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged",
                    'timeout': "2000",
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('sign-index-android', getAssertionChallenge)

                navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                }).then((newCredentialInfo) => {


                    console.log("Sign", bufToHex(newCredentialInfo.response.signature));
                    const sign1 = newCredentialInfo.response.signature;
                    if (isErrorMessage(sign1) === 1) {


                        showSignMessage(sign1);

                    } else {

                        if (sign1.byteLength > 251) {
                            var str = String.fromCharCode.apply(null, new Uint8Array(
                                sign1));
                            alert("Plaintext:" + "\n" + signShortData +
                                "\n" +
                                "\n" +
                                "Signature:" + "\n" + btoa(str));



                        } else {



                            var challenge = new Uint8Array(32);
                            window.crypto.getRandomValues(challenge);

                            var userID = 'Kosv9fPtkDoh4Oz7Yq/pVgWHS8HhdlCto5cR0aBoVMw='
                            var id = Uint8Array.from(window.atob(userID), c => c.charCodeAt(0))

                            var android_getSignature = {
                                'challenge': challenge,

                                'rp': {
                                    'name': 'GoTrustID Inc.'
                                },

                                'user': {
                                    'id': id,
                                    'name': 'FastCar@example.com',
                                    'displayName': 'Car man'
                                },

                                "authenticatorSelection": {
                                    "userVerification": "discouraged",
                                    'authenticatorAttachment': "cross-platform",
                                },

                                'pubKeyCredParams': [{
                                        'type': 'public-key',
                                        'alg': -7
                                    },
                                    {
                                        'type': 'public-key',
                                        'alg': -257
                                    }
                                ]
                            }

                            console.log('Get reponse  android', android_getSignature)
                            navigator.credentials.create({
                                    'publicKey': android_getSignature
                                }).then((newCredentialInfo) => {


                                    let attestationObject = CBOR.decode(newCredentialInfo
                                        .response.attestationObject);
                                    let authData = parseAuthData(attestationObject
                                        .authData);
                                    var CredID = authData.credID;
                                    var publicKEy = CBOR.decode(authData.COSEPublicKey
                                        .buffer);
                                    var externalECPublicKeyX = Object.values(publicKEy)[3];
                                    console.log(bufToHex(externalECPublicKeyX));
                                    var sig_buffer = new Uint8Array(256);
                                    sig_buffer[0] = externalECPublicKeyX[0];
                                    sig_buffer.set(new Uint8Array(CredID), 1);
                                    console.log('Signature:', bufToHex(sig_buffer));
                                    var str = String.fromCharCode.apply(null,
                                        new Uint8Array(
                                            sig_buffer));

                                    alert("Plaintext:" + "\n" + signShortData +
                                        "\n" +
                                        "\n" +
                                        "Signature:" + "\n" + btoa(str));

                                })
                                .catch((error) => {
                                    alert(error)
                                    console.log('FAIL', error)
                                })
                        }
                    }

                });

            });
        })
        
        document.getElementById('sign-index-safari').addEventListener('submit', function (event) {
            event.preventDefault();


            let certIndex = document.getElementById('use-index-safari').certIndex.value;
            //let userpin = document.getElementById('safari-pin-index').pin.value;
            console.log('use-index-safari', certIndex);


            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;
            var userpin;
            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(5);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 0x00
            command_bufer[3] = 0x01;
            command_bufer[4] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                userpin = prompt("Input your PIN", "");
                if (userpin == null) {
                    return;
                }
                console.log('safari-pin-index', userpin);

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);
                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(5);
                command_buf[0] = 0xDF;
                command_buf[1] = 0x02;
                command_buf[2] = 0x00;
                command_buf[3] = 0x01;
                command_buf[4] = certIndex;

                var alg_buf = new Uint8Array(5);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 0x00;
                alg_buf[3] = 0x01;
                alg_buf[4] = 0x02;


                var ecpubkey_buf = new Uint8Array(4 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength >> 8;
                ecpubkey_buf[3] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 4);


                var encryptedPIN_buf = new Uint8Array(4 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength >> 8;
                encryptedPIN_buf[3] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 4);

                var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(4 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length >> 8;
                signDataBuf[3] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 4);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf
                    .byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-index-safari: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge);

                navigator.credentials.get({
                        'publicKey': getAssertionChallenge
                    })
                    .then((newCredentialInfo) => {
                        //alert('Sign finished');
                        console.log("SUCCESS: " + bufToHex(newCredentialInfo));
                        console.log("Sign: " + bufToHex(newCredentialInfo.response.signature));
                        const sign = newCredentialInfo.response.signature;
                        showSignMessage(sign);

                    })
                    .catch((error) => {
                        alert(error)
                        console.log('FAIL', error)
                    })

            });
        })
        
        document.getElementById('sign-ckalabel-safari').addEventListener('submit', function (event) {
            event.preventDefault();


            let ckaLabel = document.getElementById('use-label-safari').ckaLabel.value;
            //let userpin = document.getElementById('safari-pin-label').pin.value;


            console.log('use-label-safari', ckaLabel);


            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;
            var userpin;
            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 4);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length >> 8;
            command_bufer[3] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 4);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {


                userpin = prompt("Input your PIN", "");
                if (userpin == null) {
                    return;
                }
                console.log('safari-pin-label', userpin);

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);


                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(ckaLabel.length + 4);
                command_buf[0] = 0xDF
                command_buf[1] = 0x01;
                command_buf[2] = ckaLabel.length >> 8;
                command_buf[3] = ckaLabel.length;
                command_buf.set(toUTF8Array(ckaLabel), 4);



                var alg_buf = new Uint8Array(5);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 0;
                alg_buf[3] = 1;
                alg_buf[4] = 0x02;


                var ecpubkey_buf = new Uint8Array(4 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength >> 8;
                ecpubkey_buf[3] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 4);


                var encryptedPIN_buf = new Uint8Array(4 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength >> 8;
                encryptedPIN_buf[3] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 4);

                var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(4 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length >> 8;
                signDataBuf[3] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 4);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-ckalabel-safari: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                        'publicKey': getAssertionChallenge
                    })
                    .then((newCredentialInfo) => {

                        console.log('SUCCESS', newCredentialInfo)
                        console.log("Sign", newCredentialInfo.response.signature)
                        const sign = newCredentialInfo.response.signature;
                        showSignMessage(sign);
                    })
                    .catch((error) => {
                        alert(error)
                        console.log('FAIL', error)
                    })

            });
        })
        
        document.getElementById('btn_gen_rsakeypair').addEventListener('submit', function (event) {

            event.preventDefault();
            var pki_buffer = [];
            let certIndex = document.getElementById('use-index').certIndex.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(5);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x16;
            command_bufer[2] = 0x0;
            command_bufer[3] = 0x01;
            command_bufer[4] = 0x02;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE6;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Index'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "none",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Gen RSA Key Pair:', publicKey1)


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject)
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));

                    let returnData = showRSAKeyPair(authData.credID);
                    document.getElementById('target_key_handle').innerText = bufToHex(returnData[1]);



                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })

        });
        
        document.getElementById('btn_sign_csr').addEventListener('submit', function (event) {
            event.preventDefault();

            let keyHandle = document.getElementById('target_key_handle').textContent;
            console.log('key_handle', keyHandle);

            var keyHandleBuf = hexStringToArrayBuffer(keyHandle);

            let testSignCSR = Uint8Array.from(window.atob(signShortData), c => c.charCodeAt(0));
            console.log('testSignCSR', testSignCSR);



            //  let signCRS = new Promise( requirePINVerify(resolve,reject));

            // requirePINVerify().then((value) => {

            //     var EncryptedPINArray = value[0];
            //     console.log("EncryptedPINArray", bufToHex(value[0]));

            //     var exportECPublicKeyArray = value[1];
            //     console.log("exportECPublicKeyArray", bufToHex(value[1]));

            //     // Test Data as CSR template
            //     var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));

            //     requestSignDataWithPINByKEYHANDLE(keyHandleBuf,exportECPublicKeyArray, EncryptedPINArray, signDataPayload).then((newCredentialInfo)=>{

            //         console.log('SUCCESS', newCredentialInfo);
            //         console.log("SignData", bufToHex(newCredentialInfo.response.signature));
            //         const sign = newCredentialInfo.response.signature;
            //         showSignMessage(sign);

            //     });
                

            // }).catch((error) => {
            //     alert(error)
            //     console.log('FAIL', error)
            // });
            var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
            requestSignDataByKEYHANDLE(keyHandleBuf, signDataPayload).then((newCredentialInfo)=>{

                console.log('SUCCESS', newCredentialInfo);
                console.log("SignData", bufToHex(newCredentialInfo.response.signature));
                const sign = newCredentialInfo.response.signature;
                showSignMessage(sign);

            });
    


        });
        
        document.getElementById('btn_import_certificate').addEventListener('submit', function (event) {
            event.preventDefault();


            let keyHandle = document.getElementById('target_key_handle').textContent;
       
            let keyId = document.getElementById('target_key_id').value;
            if(keyId.value=""){
                alert("The KEY_ID cannot empty.");
                return;
            }
            console.log('key_handle', keyHandle);
            console.log('key_id', keyId);


            //let userpin = document.getElementById('safari-pin-label').pin.value;
      
            var keyHandleBuf = hexStringToArrayBuffer(keyHandle);
       


            let hexCert = Uint8Array.from(window.atob(testCertificate), c => c.charCodeAt(0));
            console.log('hexCert', hexCert);

            var pki_buffer = [];
            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

            var pki_header = new Uint8Array(3);

            //PKI Command
            var cert_buf = new Uint8Array(hexCert.length + 4);
            cert_buf[0] = 0xDF
            cert_buf[1] = 0x17;
            cert_buf[2] = hexCert.length >> 8;
            cert_buf[3] = hexCert.length;
            cert_buf.set(hexCert, 4);


            var keyHandle_buf = new Uint8Array(keyHandleBuf.length + 4);
            keyHandle_buf[0] = 0xDF;
            keyHandle_buf[1] = 0x19;
            keyHandle_buf[2] = keyHandleBuf.length >> 8;
            keyHandle_buf[3] = keyHandleBuf.length;
            keyHandle_buf.set(new Uint8Array(keyHandleBuf), 4);


            var keyId_buf = new Uint8Array(keyId.length + 4);
            keyId_buf[0] = 0xDF;
            keyId_buf[1] = 0x18;
            keyId_buf[2] = keyId.length >> 8;
            keyId_buf[3] = keyId.length;
            keyId_buf.set(toUTF8Array(keyId), 4);

         

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + cert_buf.byteLength +
                keyHandle_buf
                .byteLength + keyId_buf.byteLength);

            var pki_payload_length = cert_buf.byteLength + keyHandle_buf.byteLength + keyId_buf
                .byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE7;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(cert_buf), gtheaderbuffer.byteLength + 3);
            pki_buffer.set(new Uint8Array(keyId_buf), gtheaderbuffer.byteLength + 3 + cert_buf
                .byteLength);
            pki_buffer.set(new Uint8Array(keyHandle_buf), gtheaderbuffer.byteLength + 3 + cert_buf
                .byteLength +
                keyId_buf.byteLength);

            console.log("Import cert command: " + bufToHex(pki_buffer));

            var getAssertionChallenge = {
                'challenge': challenge,
                "userVerification": "discouraged"
            }
            var idList = [{
                id: pki_buffer,
                transports: ["usb"],
                type: "public-key"
            }];

            getAssertionChallenge.allowCredentials = idList;
            console.log('Import cert command getAssertionChallenge', getAssertionChallenge);

            navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log("Sign", newCredentialInfo.response.signature)
                    const sign = newCredentialInfo.response.signature;
                    showSignMessage(sign);
                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })

        })
        

        


        
    </script>

</body>

</html>