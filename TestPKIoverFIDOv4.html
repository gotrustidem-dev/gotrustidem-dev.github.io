<!DOCTYPE html>
<html>

<head>
    <title>GoTrustIdem TestPKI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Ensure use of most common Unicode characters -->
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <!-- Considered an "experimental" feature -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css" />
    <!-- Spectre.css icons are used -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <script src="https://gotrustidem-dev.github.io/utils/cbor.js"></script>
    <script src="https://gotrustidem-dev.github.io/utils/helpers.js"></script>
    <script src="https://gotrustidem-dev.github.io/utils/showMessage.js"></script>
    <script src="https://gotrustidem-dev.github.io/utils/PKIoverFIDO.js"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'UA-3776848-14');
    </script>
    <script>
        (function (d) {
            var wf = d.createElement('script'),
                s = d.scripts[0];
            wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js';
            wf.async = true;
            s.parentNode.insertBefore(wf, s);
        })(document);
    </script>
    <script src="https://gotrustidem-dev.github.io/library/jquery.min.js"></script>
    <script src="https://gotrustidem-dev.github.io/library/bootstrap.min.js"
        integrity="sha256-Tz+u7EaSlLYQ9sqCqhzCszaP1WYRsxxVHC7iJP6ttBE=" crossorigin="anonymous"></script>
    <script async="" src="https://gotrustidem-dev.github.io/library/bundle.js"></script>
    <script>
        function displayCert(strCertificate) {

            $('#certificate').text(strCertificate)
            window.setTimeout(function () {
                console.log("Timeout ... trigger decode");
                $("#decode .btn").click();
            }, 100);


        }



        $(document).ready(function () {

            var pctd = document.getElementById('pc-td');
            var androidtd = document.getElementById('android-td');
            var safaritd = document.getElementById('safari-td');
            var macsafaritd = document.getElementById('mac-safari-td');

            var WhatSystem = navigator.userAgent;
            console.log(WhatSystem);
            if (WhatSystem.match("Android")) {
                console.log("This is android");
                pctd.style.display = 'none';
                safaritd.style.display = 'none';
                macsafaritd.style.display = 'none';
            } else if (WhatSystem.match("Windows")) {
                safaritd.style.display = 'none';
                androidtd.style.display = 'none';
                macsafaritd.style.display = 'none';
            } else if (WhatSystem.match("Safari")) {

                if (WhatSystem.match("Chrome")) {
                    safaritd.style.display = 'none';
                    androidtd.style.display = 'none';
                    macsafaritd.style.display = 'none';
                } else if (WhatSystem.match("Mac OS X") && WhatSystem.match("Version/14")) {
                    safaritd.style.display = 'none';
                    androidtd.style.display = 'none';
                    macsafaritd.style.display = 'none';
                } else {
                    pctd.style.display = 'none';
                    androidtd.style.display = 'none';
                    macsafaritd.style.display = 'none';
                }

            }


            var btnDecode = document.getElementById('decode');
            btnDecode.style.visibility = 'hidden';

            var ctrlErr = document.getElementById('upload-error');
            ctrlErr.style.visibility = 'hidden';

            var ctrlCert = document.getElementById('certificate');
            ctrlCert.style.visibility = 'hidden';

            var formcert = document.getElementById('form');
            formcert.style.visibility = 'hidden';
        });
    </script>
    <style>
        table.center {
            margin-left: auto;
            margin-right: auto;
            height: 160px;
        }

        table td,
        table td * {
            vertical-align: top;
        }

        h3 {
            text-align: center;
        }
    </style>
</head>

<body>
    <img style=" width: 100%; height: 100%;" src="./IdemHeader.png" alt="Idem Key icon " height="476" />
    <div style="overflow-x: scroll;">
        <table style="height: auto; width: 100%;">
            <tbody>

                <tr>
                    <td style="width: 100% ;">

                        <form style="text-align: center;" id="btn_token_info" onsubmit="return false">
                            <button class="btn btn-primary" action="submit"
                                style="width: 162px; height:34px;background-color: #008CBA;">Token Information</button>
                            <br>
                            <label id="label_token_fw"></label><br>
                            <label id="label_token_sw"></label><br>
                            <label id="label_pin_retries"></label><br>
                            <label id="label_credentials"></label><br>
                            <label id="label_serial_number"></label><br>
                            <label id="label_random_number"></label><br>
                            <label id="label_ecPublic_key"></label><br>
                        </form>


                    </td>
                </tr>


                <tr>
                    <td id="pc-td" style="width: 100% ; ">
                        <table class="center" border="1" width="395">
                            <tbody>
                                <tr>
                                    <form style="text-align: center;" id="form_token_sn"
                                    onsubmit="return false">

                                    <p>
                                        <label id="label_token_sn">Token Serial number:</label><br>
                                        <input type="text" id="target_token_sn"
                                            style="width: 342px; height:41px">
                                    </p>

                            
                                </form>


                                </tr>
                                <tr>
                                    <!--PC side-->
                                    <td style="width: 385px;">
                                        <p style="text-align: center;">Operate by CKA_LABEL</p>

                                        <p>
                                            <form style="text-align: center;" id="use-label" onsubmit="return false">
                                                <input type="text" name="ckaLabel" style="width: 342px; height:41px">
                                            </form>
                                        </p>
                                        <form style="text-align: center;" id="search-ckalabel" onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 200px; height:34px;background-color: #008CBA;">Read
                                                Certificate</button>
                                        </form>

                                        <br>
                                        <form style="text-align: center;" id="search-ckalabel-nopin"
                                            onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 200px; height:34px;background-color: #008CBA;">Read
                                                Certificate no pin</button>
                                        </form>

                                        <p>
                                            <form style="text-align: center;" id="sign-byckalabel"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 200px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>


                                    <td style="width: 385px;">
                                        <p style="text-align: center;">Operate by Index (1~8)</p>
                                        <p>
                                            <form style="text-align:center" id="use-index" onsubmit="return false">
                                                <input type="number" name="certIndex" style="width: 342px; height:41px">
                                            </form>
                                        </p>
                                        <form style="text-align: center;" id="find-index" onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 200px; height:34px;background-color: #008CBA;">Read
                                                Certificate</button>
                                        </form>

                                        <br>
                                        <form style="text-align: center;" id="find-index-nopin" onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 200px; height:34px;background-color: #008CBA;">Read
                                                Certificate no pin</button>
                                        </form>


                                        <p>
                                            <form style="text-align: center;" id="sign-byindex" onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 200px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>

                                    <td style="width: 385px;">
                                        <p style="text-align: center;">Regisitration </p>
                                        <p>
                                            <form style="text-align: center;" id="btn_gen_rsakeypair"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Gen RSA
                                                    Key Pair</button>

                                                <p>
                                                    <label id="key_handle_value">Key Handle:</label>
                                                    <label id="target_key_handle"></label>
                                                </p>
                                            </form>
                                            <form style="text-align: center;" id="btn_sign_csr" onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign a
                                                    CSR</button>
                                            </form>

                                            <!-- <form style="text-align: center;" id="btn_test_mutliread" onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Test Read cert by sign</button>
                                            </form> -->

                                            <!-- <form style="text-align: center;" id="btn_test_tokeninfo" onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Test Get Token Info</button>
                                            </form> -->


                                            <!-- <form style="text-align: center;" id="btn_import_certificate"
                                                onsubmit="return false">
                                                <p>
                                                    <label id="key_id_value">Key ID:</label><br>
                                                    <input type="text" id="target_key_id"
                                                        style="width: 342px; height:41px">
                                              </p>
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Import
                                                    Cert. to Key</button> 

                                            </form>  -->

                                            <form style="text-align: center;" id="btn_import_certificate2"
                                                onsubmit="return false">

                                                <p>
                                                    <label id="key_id_value">Key ID:</label><br>
                                                    <input type="text" id="target_key_id"
                                                        style="width: 342px; height:41px">
                                                </p>

                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Import
                                                    Certificate</button>

                                            </form>
                                        </p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>

                    <td id="android-td" style="width: 329px;">

                        <table style="height: 160px;" border="1" width="395">
                            <tbody>
                                <tr>
                                    <td style="width: 385px; height: 233px; vertical-align:top">
                                        <p style="text-align: center;">Operate by CKA_LABEL</p>

                                        <p>
                                            <form style="text-align: center;" id="android-label"
                                                onsubmit="return false">
                                                <input type="text" name="ckaLabel" style="width: 342px; height:41px">
                                            </form>
                                        </p>

                                        <p>
                                            <form style="text-align: center;" id="android-ckalabel-getassertion"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>
                                </tr>

                                <tr>
                                    <td style="width: 385px; height: 233px; vertical-align:top">
                                        <p style="text-align: center;">Operate by Index (1~8)</p>

                                        <p>
                                            <form style="text-align: center;" id="android-index"
                                                onsubmit="return false">
                                                <input type="number" name="certIndex" style="width: 342px; height:41px">
                                            </form>
                                        </p>

                                        <p>
                                            <form style="text-align: center;" id="android-index-getassertion"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                    <td id="safari-td" style="width: 329px; ">

                        <table style="height: 160px;" border="1" width="395">
                            <tbody>
                                <tr>
                                    <td style="width: 385px; ">
                                        <p style="text-align: center;">Operate by CKA_LABEL</p>

                                        <p>
                                            <form style="text-align: center;" id="use-label-safari"
                                                onsubmit="return false">
                                                <input type="text" name="ckaLabel" style="width: 342px; height:41px">

                                            </form>
                                        </p>


                                        <form style="text-align: center;" id="search-ckalabel-safari"
                                            onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                Certificate</button>
                                        </form>
                                        <p>
                                            <form style="text-align: center;" id="sign-ckalabel-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>

                                </tr>
                                <tr>
                                    <td style="width: 385px;">
                                        <p style="text-align: center;">Operate Certificate by Index (1~8)</p>
                                        <p>
                                            <form style="text-align:center" id="use-index-safari"
                                                onsubmit="return false">
                                                <input type="number" name="certIndex" style="width: 342px; height:41px">
                                            </form>
                                        </p>
                                        <p>
                                            <form style="text-align: center;" id="find-index-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                    Certificate</button>
                                            </form>
                                        </p>

                                        <p>
                                            <form style="text-align: center;" id="sign-index-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>
                                </tr>


                            </tbody>
                        </table>
                    </td>

                    <td id="mac-safari-td" style="width: 329px; ">

                        <table class="center" style="height: 160px;" border="1" width="395">
                            <tbody>
                                <tr>
                                    <td style="width: 385px; ">
                                        <p style="text-align: center;">Operate by CKA_LABEL</p>

                                        <p>
                                            <form style="text-align: center;" id="use-label-safari"
                                                onsubmit="return false">
                                                <input type="text" name="ckaLabel" style="width: 342px; height:41px">

                                            </form>
                                        </p>


                                        <form style="text-align: center;" id="search-ckalabel-safari"
                                            onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                Certificate</button>
                                        </form>
                                        <p>
                                            <form style="text-align: center;" id="sign-ckalabel-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>
                                    <td style="width: 385px;">
                                        <p style="text-align: center;">Operate Certificate by Index (1~8)</p>
                                        <p>
                                            <form style="text-align:center" id="use-index-safari"
                                                onsubmit="return false">
                                                <input type="number" name="certIndex" style="width: 342px; height:41px">
                                            </form>
                                        </p>
                                        <p>
                                            <form style="text-align: center;" id="find-index-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                    Certificate</button>
                                            </form>
                                        </p>

                                        <p>
                                            <form style="text-align: center;" id="sign-index-safari"
                                                onsubmit="return false">
                                                <button class="btn btn-primary" action="submit"
                                                    style="width: 162px; height:34px;background-color: #008CBA;">Sign</button>
                                            </form>
                                        </p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>

                </tr>
            </tbody>
        </table>
    </div>


    <!--  Laurence -->
    <div class="container mt-2">
        <div id="form" class="mt-2 mb-2">
            <div class="container">
                <div class="row">
                    <div class="col">
                        <div class="card">
                            <div class="card-body">
                                <div id="results" class="d-none mt-2"></div>
                                <form>
                                    <div class="form-group">
                                        <textarea class="form-control certificate" id="certificate" rows="8"
                                            style="white-space: pre" required="" autofocus=""></textarea>

                                        <div id="upload-error" class="alert alert-danger alert-dismissible mt-1"
                                            style="display: none;" role="alert">
                                            <small id="upload-error-message"></small>
                                            <button type="button" class="close" aria-label="Close"
                                                onclick="$(&#39;#upload-error&#39;).hide()">
                                                <span aria-hidden="true">×</span></button></div>
                                    </div>
                                    <div class="text-center">
                                        <div id="decode">
                                            <button id="btn_decode" type="submit"
                                                class="btn btn-primary btn-lg">Decode</button>
                                        </div>
                                        <div id="error" class="alert alert-danger alert-dismissible mt-2"
                                            style="display: none;" role="alert">
                                            <span id="error-message"></span>
                                            <button type="button" class="close" aria-label="Close"
                                                onclick="$(&#39;#error&#39;).hide()">
                                                <span aria-hidden="true">×</span></button>
                                        </div>
                                    </div>

                                    <div id="cert-info-warn" class="alert alert-warning mt-3">
                                        <small>Certificate information will never leave your browser. Decoding happens
                                            using client-side JavaScript.</small>
                                    </div>
                                </form>

                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Command Header GoTrust-Idem-PKI
        //var GTheader = 'R29UcnVzdC1JZGVtLVBLSQ==';

        // signed Data1: 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef  
        var signData =
            'MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWY=';


        //  signed Data2:  1234567890abcdef1234567890abcdef
        var signShortData = 'MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWY=';

        var testCertificate =
            'MIIDHjCCAgagAwIBAgIEG0BT9zANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNZdWJpY28gVTJGIFJvb3QgQ0EgU2VyaWFsIDQ1NzIwMDYzMTAgFw0xNDA4MDEwMDAwMDBaGA8yMDUwMDkwNDAwMDAwMFowLjEsMCoGA1UEAxMjWXViaWNvIFUyRiBSb290IENBIFNlcmlhbCA0NTcyMDA2MzEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC/jwYuhBVlqaiYWEMsrWFisgJ+PtM91eSrpI4TK7U53mwCIawSDHy8vUmk5N2KAj9abvT9NP5SMS1hQi3usxoYGonXQgfO6ZXyUA9a+KAkqdFnBnlyugSeCOep8EdZFfsaRFtMjkwz5Gcz2Py4vIYvCdMHPtwaz0bVuzneueIEz6TnQjE63Rdt2zbwnebwTG5ZybeWSwbzy+BJ34ZHcUhPAY89yJQXuE0IzMZFcEBbPNRbWECRKgjq//qT9nmDOFVlSRCt2wiqPSzluwn+v+suQEBsUjTGMEd25tKXXTkNW21wIWbxeSyUoTXwLvGS6xlwQSgNpk2qXYwf8iXg7VWZAgMBAAGjQjBAMB0GA1UdDgQWBBQgIvz0bNGJhjgpToksyKpP9xv9oDAPBgNVHRMECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAQEAjvjuOMDSa+JXFCLyBKsycXtBVZsJ4Ue3LbaEsPY4MYN/hIQ5ZM5p7EjfcnMG4CtYkNsfNHc0AhBLdq45rnT87q/6O3vUEtNMafbhU6kthX7Y+9XFN9NpmYxr+ekVY5xOxi8h9JDIgoMP4VB1uS0aunL1IGqrNooL9mmFnL2kLVVee6/VR6C5+KSTCMCWppMuJIZII2v9o4dkoZ8Y7QRjQlLfYzd3qGtKbw7xaF1UsG/5xUb/Btwb2X2g4InpiB/yt/3CpQXpiWX/K4mBvUKiGn05ZsqeY1gx4g0xLBqcU9psmyPzK+Vsgw2jeRQ5JlKDyqE0hebfC1tvFu0CCrJFcw==';

        var testBigCertificate =
            'MIIGQTCCBCmgAwIBAgIQZZoQ3+1f84xqfignfZA0VzANBgkqhkiG9w0BAQsFADCBhDELMAkGA1UEBhMCVFcxIzAhBgNVBAoTGkNodW5naHdhIFRlbGVjb20gQ28uLCBMdGQuMScwJQYDVQQLEx5GaW5hbmNpYWwgVUNBIGZvciBUZXN0aW5nIC0gRzQxJzAlBgNVBAMTHlRlc3QgVUNBIG9mIEZpbmFuY2lhbCBQS0kgLSBHNDAeFw0yMDA1MjgwODU2MThaFw0yMTA1MjgwODU2MThaMIGpMQswCQYDVQQGEwJUVzEjMCEGA1UECgwaQ2h1bmdId2EgVGVsZWNvbSBDby4sIEx0ZC4xLzAtBgNVBAsMJkZpbmFuY2lhbCBVc2VyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRswGQYDVQQLDBI4MDY5MDcyLVl1YW50YUJhbmsxDTALBgNVBAsMBEZYTUwxGDAWBgNVBAMMDzIwMjAwNTI4LS0wMDAwMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKrgyE7QRgFhDJ5koq9ot4e+xhH8WfY5cA5QGXG2uj3xaAMp4+ST9e8ClHsJ3TH21VCyHup0Oby31jbkfNfVTf/LRQiDMxGnpQeW0vzbKgI5vBgjTpTHRN9ojQp+APg45S5diEeJklZFwFU5WZtO6PKjoye22T2XJAnWUzW2l4rOxwftbmeAOMOa2q641D0oYzWTb8MWI76vPZFxtIyCpmXovVTgs0fOFqFztnkKQEr18yfpW9oVsKHmKI246OFDJ/1jOLX7Oga4P4fXjSCyB6ABiZD752g980kk0QflI0+RjgKM2ayku6ms6I8YcthWib0tLGxdolMAQptZbG2QfCUCAwEAAaOCAYYwggGCMH8GCCsGAQUFBwEBBHMwcTA9BggrBgEFBQcwAoYxaHR0cDovL3Rlc3RmY2EuaGluZXQubmV0L2NlcnRzL0lzc3VlZFRvVGhpc0NBLnA3YjAwBggrBgEFBQcwAYYkaHR0cDovL3Rlc3RmY2EuaGluZXQubmV0L09DU1Avb2NzcEc0MBQGA1UdIAQNMAswCQYHYIEeAwEDBTAOBgNVHQ8BAf8EBAMCBsAwKwYDVR0jBCQwIoAg2c9SjMGYrXoC2hTwWn+quhjNgG4H28IYXPfNQK2gmvUwKQYDVR0OBCIEIPdVZrvZQl08qk5wklq/wF4T99Gz1bCB+ccCOWGyAxAUMIGABgNVHR8EeTB3MD2gO6A5hjdodHRwOi8vdGVzdGZjYS5oaW5ldC5uZXQvY3JsL0ZVQ0FHNC8zMDA5LTEvY29tcGxldGUuY3JsMDagNKAyhjBodHRwOi8vdGVzdGZjYS5oaW5ldC5uZXQvY3JsL0ZVQ0FHNC9jb21wbGV0ZS5jcmwwDQYJKoZIhvcNAQELBQADggIBADz9KMQ9+oQYml+z1ehNs6e6FIOdQY0aucyW2CdtagqqOn0HWyLp+upulNOPnMi3Axq3PmZ8xWK5XSKRTVXbcRralEYlZmRSss/ErI7hYxAxu6n3uWwpUFGPFt55Ihw8+nIF3Wy8IAF3yryZLnr8pfQY2C1tpwdBgLOa/tO2Mo2l6qrcljf+RiQizydL42g3KO1RSh55+BKMMSZ8cubetJ1Fdfauyj+SbRasGqX3p4eF325RGbVLikOW53hXX1kJ933a423F2wR6ctilq5m/iDlbd7QDwJ14u6inmWtjGkg2FUuQXWj+onIjjqbNDwQGiqunxsMvKu9uYXNQYjwtpoonadxwEs3rHExu/8n9ggk5xiJGefhW7+nNKSnbO13kUh00wHIM9vOXffOP/3Ze6wW2J4qqK3k/CV+iqgBCZo7iewdT+KN8i75i1LyYceO4/bXlWm2xjUyLQX6lEkrK5vvsv5GnQB/v2EwqPtAJhJcwU5Qfk3vRN3m3LsW9AXXgZc+5gsgYjMtW9Jz2ajAPuWhUrMnGVo57bRyNEssFdftDXZCqleql3+J3SgyRObazbA93l/ws7Yc9tE/y1nSIziRDxy9TrYPKLRin/MKvASt90n2Sx7eU8nmnjKOnSCO/VwjpbBW+IUD099Zx1jb7ctBk77IDEbCZxWmNbzXHlazF';

        document.getElementById('find-index').addEventListener('submit', function (event) {
            event.preventDefault();
            let certIndex = document.getElementById('use-index').certIndex.value;
            ReadCertByIndex(certIndex).then((value) => {

                var strCert = "-----BEGIN CERTIFICATE-----\n" +
                    btoa(String.fromCharCode.apply(null, value)) +
                    "\n-----END CERTIFICATE-----"

                console.log('Certificatie : \n', strCert)
                displayCert(strCert)


            });
        })

        document.getElementById('find-index-nopin').addEventListener('submit', function (event) {
            event.preventDefault();
            let certIndex = document.getElementById('use-index').certIndex.value;
            ReadCertByIndexFunction2(certIndex).then((value) => {


                let responseData = parsePKIoverFIDOResponse(value);

                if (responseData.status === CTAP1_ERR_SUCCESS) {
                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, responseData.signature)) +
                        "\n-----END CERTIFICATE-----"
                    console.log('Certificatie : \n', strCert)
                    displayCert(strCert);
                } else if (responseData.status === CTAP2_ERR_NO_CREDENTIALS) {

                    alert("No valid credentials provided");
                } else {
                    alert("Error ocured. Status code: " + responseData.status);

                }
            }).catch((error) => {
                alert(error)
                console.log('FAIL', error)
            });


        })


        document.getElementById('search-ckalabel').addEventListener('submit', function (event) {
            event.preventDefault();
            let ckaLabel = document.getElementById('use-label').ckaLabel.value;
            ReadCertByLable(ckaLabel).then((value) => {

                var strCert = "-----BEGIN CERTIFICATE-----\n" +
                    btoa(String.fromCharCode.apply(null, value)) +
                    "\n-----END CERTIFICATE-----"
                console.log('Certificatie : \n', strCert)
                displayCert(strCert)
            });

        })


        document.getElementById('search-ckalabel-nopin').addEventListener('submit', function (event) {
            event.preventDefault();
            let ckaLabel = document.getElementById('use-label').ckaLabel.value;
            ReadCertByLableFunction2(ckaLabel).then((value) => {

                let responseData = parsePKIoverFIDOResponse(value);


                if (responseData.status === CTAP1_ERR_SUCCESS) {
                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, responseData.signature)) +
                        "\n-----END CERTIFICATE-----"
                    console.log('Certificatie : \n', strCert)
                    displayCert(strCert);
                } else if (responseData.status === CTAP2_ERR_NO_CREDENTIALS) {

                    alert("No valid credentials provided");
                } else {
                    alert("Error ocured. Status code: " + responseData.status);

                }


            }).catch((error) => {
                alert(error)
                console.log('FAIL', error)
            });
        })


        document.getElementById('sign-byindex').addEventListener('submit', function (event) {
            event.preventDefault();
            var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
            let certIndex = document.getElementById('use-index').certIndex.value;
            SignDataByIndex(certIndex, 0x02, signDataPayload).then((value) => {

                showSignMessage(value);

            });
        })

        document.getElementById('sign-byckalabel').addEventListener('submit', function (event) {
            event.preventDefault();
            var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
            let ckaLabel = document.getElementById('use-label').ckaLabel.value;
            SignDataByLabel(ckaLabel, 0x02, signDataPayload).then((value) => {
                showSignMessage(value);
            });
        })



        document.getElementById('search-ckalabel-safari').addEventListener('submit', function (event) {
            event.preventDefault();
            var pki_buffer = [];
            let ckaLabel = document.getElementById('use-label-safari').ckaLabel.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 4);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length >> 8;
            command_bufer[3] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 4);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Label'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "userVerification": "discouraged",
                    "authenticatorAttachment": "cross-platform",


                },
                'attestation': "none",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('search-ckalabel-safari', bufToHex(publicKey1));


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject);
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));


                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, new Uint8Array(authData.credID.slice(1,
                            authData.credID.length)))) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)



                    displayCert(strCert)




                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })

        document.getElementById('find-index-safari').addEventListener('submit', function (event) {
            event.preventDefault();

            let certIndex = document.getElementById('use-index-safari').certIndex.value;
            ReadCertByIndex(certIndex).then((value) => {

                var strCert = "-----BEGIN CERTIFICATE-----\n" +
                    btoa(value) +
                    "\n-----END CERTIFICATE-----"

                console.log('Certificatie : \n', strCert)
                displayCert(strCert)


            });
        })

        document.getElementById('sign-index-safari').addEventListener('submit', function (event) {
            event.preventDefault();


            let certIndex = document.getElementById('use-index-safari').certIndex.value;
            //let userpin = document.getElementById('safari-pin-index').pin.value;
            console.log('use-index-safari', certIndex);


            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;
            var userpin;
            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(5);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 0x00
            command_bufer[3] = 0x01;
            command_bufer[4] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                userpin = prompt("Input your PIN", "");
                if (userpin == null) {
                    return;
                }
                console.log('safari-pin-index', userpin);

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);
                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(5);
                command_buf[0] = 0xDF;
                command_buf[1] = 0x02;
                command_buf[2] = 0x00;
                command_buf[3] = 0x01;
                command_buf[4] = certIndex;

                var alg_buf = new Uint8Array(5);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 0x00;
                alg_buf[3] = 0x01;
                alg_buf[4] = 0x02;


                var ecpubkey_buf = new Uint8Array(4 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength >> 8;
                ecpubkey_buf[3] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 4);


                var encryptedPIN_buf = new Uint8Array(4 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength >> 8;
                encryptedPIN_buf[3] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 4);

                var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(4 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length >> 8;
                signDataBuf[3] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 4);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf
                    .byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-index-safari: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge);

                navigator.credentials.get({
                        'publicKey': getAssertionChallenge
                    })
                    .then((newCredentialInfo) => {
                        //alert('Sign finished');
                        console.log("SUCCESS: " + bufToHex(newCredentialInfo));
                        console.log("Sign: " + bufToHex(newCredentialInfo.response.signature));
                        const sign = newCredentialInfo.response.signature;
                        showSignMessage(sign);

                    })
                    .catch((error) => {
                        alert(error)
                        console.log('FAIL', error)
                    })

            });
        })

        document.getElementById('sign-ckalabel-safari').addEventListener('submit', function (event) {
            event.preventDefault();


            let ckaLabel = document.getElementById('use-label-safari').ckaLabel.value;
            //let userpin = document.getElementById('safari-pin-label').pin.value;


            console.log('use-label-safari', ckaLabel);


            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;
            var userpin;
            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 4);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length >> 8;
            command_bufer[3] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 4);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {


                userpin = prompt("Input your PIN", "");
                if (userpin == null) {
                    return;
                }
                console.log('safari-pin-label', userpin);

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);


                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(ckaLabel.length + 4);
                command_buf[0] = 0xDF
                command_buf[1] = 0x01;
                command_buf[2] = ckaLabel.length >> 8;
                command_buf[3] = ckaLabel.length;
                command_buf.set(toUTF8Array(ckaLabel), 4);



                var alg_buf = new Uint8Array(5);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 0;
                alg_buf[3] = 1;
                alg_buf[4] = 0x02;


                var ecpubkey_buf = new Uint8Array(4 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength >> 8;
                ecpubkey_buf[3] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 4);


                var encryptedPIN_buf = new Uint8Array(4 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength >> 8;
                encryptedPIN_buf[3] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 4);

                var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(4 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length >> 8;
                signDataBuf[3] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 4);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-ckalabel-safari: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                        'publicKey': getAssertionChallenge
                    })
                    .then((newCredentialInfo) => {

                        console.log('SUCCESS', newCredentialInfo)
                        console.log("Sign", newCredentialInfo.response.signature)
                        const sign = newCredentialInfo.response.signature;
                        showSignMessage(sign);
                    })
                    .catch((error) => {
                        alert(error)
                        console.log('FAIL', error)
                    })

            });
        })

        document.getElementById('android-ckalabel-getassertion').addEventListener('submit', function (event) {
            event.preventDefault();




            let ckaLabel = document.getElementById('android-label').ckaLabel.value;
            //let userpin = document.getElementById('android-ckalabel-pin').pin.value;

            var userpin = prompt("Input your PIN", "");
            if (userpin == null) {
                return;
            }
            console.log('android-label', ckaLabel);
            console.log('android-ckalabel-pin', userpin);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 4);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length >> 8;
            command_bufer[3] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 4);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);


                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                var local_publicKey = key.publicKey;
                var local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(ckaLabel.length + 4);
                command_buf[0] = 0xDF
                command_buf[1] = 0x01;
                command_buf[2] = ckaLabel.length >> 8;
                command_buf[3] = ckaLabel.length;
                command_buf.set(toUTF8Array(ckaLabel), 4);



                var alg_buf = new Uint8Array(5);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 00;
                alg_buf[3] = 01;
                alg_buf[4] = 0x02;


                var ecpubkey_buf = new Uint8Array(4 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength >> 8;
                ecpubkey_buf[3] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 4);


                var encryptedPIN_buf = new Uint8Array(4 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength >> 8;
                encryptedPIN_buf[3] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 4);

                var signDataPayload = Uint8Array.from(window.atob(signShortData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(4 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length >> 8;
                signDataBuf[3] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 4);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE4;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-ckalabel-android: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                }).then((newCredentialInfo) => {

                    const sign1 = newCredentialInfo.response.signature;
                    if (sign1.byteLength < 251) {

                        var challenge = new Uint8Array(32);
                        window.crypto.getRandomValues(challenge);

                        var userID = 'Kosv9fPtkDoh4Oz7Yq/pVgWHS8HhdlCto5cR0aBoVMw='
                        var id = Uint8Array.from(window.atob(userID), c => c.charCodeAt(0))

                        var android_getSignature = {
                            'challenge': challenge,

                            'rp': {
                                'name': 'GoTrustID Inc.'
                            },

                            'user': {
                                'id': id,
                                'name': 'FastCar@example.com',
                                'displayName': 'Car man'
                            },

                            "authenticatorSelection": {
                                "userVerification": "discouraged",
                                'authenticatorAttachment': "cross-platform",
                            },

                            'pubKeyCredParams': [{
                                    'type': 'public-key',
                                    'alg': -7
                                },
                                {
                                    'type': 'public-key',
                                    'alg': -257
                                }
                            ]
                        }

                        console.log('Get reponse  android', android_getSignature)
                        navigator.credentials.create({
                                'publicKey': android_getSignature
                            }).then((newCredentialInfo) => {


                                let attestationObject = CBOR.decode(newCredentialInfo
                                    .response.attestationObject);
                                let authData = parseAuthData(attestationObject.authData);
                                var CredID = authData.credID;
                                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                                var externalECPublicKeyX = Object.values(publicKEy)[3];
                                console.log(bufToHex(externalECPublicKeyX));
                                var sig_buffer = new Uint8Array(256);
                                sig_buffer[0] = externalECPublicKeyX[0];
                                sig_buffer.set(new Uint8Array(CredID), 1);
                                console.log('Signature:', bufToHex(sig_buffer));
                                var str = String.fromCharCode.apply(null, new Uint8Array(
                                    sig_buffer));
                                alert("Plaintext:" + "\n" + signShortData +
                                    "\n" +
                                    "\n" +
                                    "Signature:" + "\n" + btoa(str));

                            })
                            .catch((error) => {
                                alert(error)
                                console.log('FAIL', error)
                            })
                    } else {

                        console.log('SUCCESS', newCredentialInfo);
                        console.log("Sign", newCredentialInfo.response.signature);
                        const sign1 = newCredentialInfo.response.signature;


                        var str = String.fromCharCode.apply(null, new Uint8Array(
                            sign1));
                        alert("Plaintext:" + "\n" + signShortData +
                            "\n" +
                            "\n" +
                            "Signature:" + "\n" + btoa(str));
                    }
                });

            });
        })

        document.getElementById('android-index-getassertion').addEventListener('submit', function (event) {
            event.preventDefault();


            let certIndex = document.getElementById('android-index').certIndex.value;
            var userpin;


            console.log('android-index', certIndex);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(5);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 0;
            command_bufer[3] = 01;
            command_bufer[4] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var android_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key request', android_readecdh);

            navigator.credentials.create({
                'publicKey': android_readecdh
            }).then((newCredentialInfo) => {
                userpin = prompt("Input your PIN", "");
                if (userpin == null) {
                    return;
                }
                console.log('android-index-pin', userpin);

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                //console.log("externalECPublicKeyX ", externalECPublicKeyX);
                //console.log("externalECPublicKeyY", externalECPublicKeyY);
                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(5);
                command_buf[0] = 0xDF;
                command_buf[1] = 0x02;
                command_buf[2] = 0;
                command_buf[3] = 01;
                command_buf[4] = certIndex;

                var alg_buf = new Uint8Array(5);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 0;
                alg_buf[3] = 01;
                alg_buf[4] = 0x02;


                var ecpubkey_buf = new Uint8Array(4 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength >> 8;
                ecpubkey_buf[3] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 4);


                var encryptedPIN_buf = new Uint8Array(4 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength >> 8;
                encryptedPIN_buf[3] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 4);

                var signDataPayload = Uint8Array.from(window.atob(signShortData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(4 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length >> 8;
                signDataBuf[3] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 4);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf
                    .byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-index-android-command: " + bufToHex(pki_buffer));
                console.log("sign-index-android-data: " + bufToHex(signDataBuf));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged",
                    'timeout': "2000",
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('sign-index-android', getAssertionChallenge)

                navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                }).then((newCredentialInfo) => {


                    console.log("Sign", bufToHex(newCredentialInfo.response.signature));
                    const sign1 = newCredentialInfo.response.signature;
                    if (isErrorMessage(sign1) === 1) {


                        showSignMessage(sign1);

                    } else {

                        if (sign1.byteLength > 251) {
                            var str = String.fromCharCode.apply(null, new Uint8Array(
                                sign1));
                            alert("Plaintext:" + "\n" + signShortData +
                                "\n" +
                                "\n" +
                                "Signature:" + "\n" + btoa(str));



                        } else {



                            var challenge = new Uint8Array(32);
                            window.crypto.getRandomValues(challenge);

                            var userID = 'Kosv9fPtkDoh4Oz7Yq/pVgWHS8HhdlCto5cR0aBoVMw='
                            var id = Uint8Array.from(window.atob(userID), c => c.charCodeAt(0))

                            var android_getSignature = {
                                'challenge': challenge,

                                'rp': {
                                    'name': 'GoTrustID Inc.'
                                },

                                'user': {
                                    'id': id,
                                    'name': 'FastCar@example.com',
                                    'displayName': 'Car man'
                                },

                                "authenticatorSelection": {
                                    "userVerification": "discouraged",
                                    'authenticatorAttachment': "cross-platform",
                                },

                                'pubKeyCredParams': [{
                                        'type': 'public-key',
                                        'alg': -7
                                    },
                                    {
                                        'type': 'public-key',
                                        'alg': -257
                                    }
                                ]
                            }

                            console.log('Get reponse  android', android_getSignature)
                            navigator.credentials.create({
                                    'publicKey': android_getSignature
                                }).then((newCredentialInfo) => {


                                    let attestationObject = CBOR.decode(newCredentialInfo
                                        .response.attestationObject);
                                    let authData = parseAuthData(attestationObject
                                        .authData);
                                    var CredID = authData.credID;
                                    var publicKEy = CBOR.decode(authData.COSEPublicKey
                                        .buffer);
                                    var externalECPublicKeyX = Object.values(publicKEy)[3];
                                    console.log(bufToHex(externalECPublicKeyX));
                                    var sig_buffer = new Uint8Array(256);
                                    sig_buffer[0] = externalECPublicKeyX[0];
                                    sig_buffer.set(new Uint8Array(CredID), 1);
                                    console.log('Signature:', bufToHex(sig_buffer));
                                    var str = String.fromCharCode.apply(null,
                                        new Uint8Array(
                                            sig_buffer));

                                    alert("Plaintext:" + "\n" + signShortData +
                                        "\n" +
                                        "\n" +
                                        "Signature:" + "\n" + btoa(str));

                                })
                                .catch((error) => {
                                    alert(error)
                                    console.log('FAIL', error)
                                })
                        }
                    }

                });

            });
        })

        document.getElementById('btn_gen_rsakeypair').addEventListener('submit', function (event) {

            event.preventDefault();
            GenRSA2048KeyPair().then((value) => {
                Msg = "Key handler: " + bufToHex(value[1]) + "\n" +
                    "PublicKey: " + bufToHex(value[2]);
                alert(Msg);
                document.getElementById('target_key_handle').innerText = bufToHex(value[1]);

            }).catch((error) => {
                alert("Test")
                console.log('FAIL', error)
            });
        });


        document.getElementById('btn_sign_csr').addEventListener('submit', function (event) {
            event.preventDefault();

            let keyHandle = document.getElementById('target_key_handle').textContent;
            console.log('key_handle', keyHandle);

            var keyHandleBuf = hexStringToArrayBuffer(keyHandle);

            let testSignCSR = Uint8Array.from(window.atob(signShortData), c => c.charCodeAt(0));
            console.log('testSignCSR', testSignCSR);

            var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
            requestSignDataByKEYHANDLE(keyHandleBuf, 0x02, signDataPayload).then((newCredentialInfo) => {
                console.log('SUCCESS', newCredentialInfo);
                let responseData = parsePKIoverFIDOResponse(newCredentialInfo.response.signature);
                console.log('PKIoverFIDO signature', responseData.signature);
                var str = String.fromCharCode.apply(null, responseData.signature);
                alert("Signature:" + "\n" + btoa(str));

            }).catch((error) => {
                alert(error)
                console.log('FAIL', error)
            });
        });




        document.getElementById('btn_token_info').addEventListener('submit', function (event) {
            event.preventDefault();

            GetTokenInfo().then((newCredentialInfo) => {
                console.log('SUCCESS', newCredentialInfo);

                //let responseData = parsePKIoverFIDOResponse(newCredentialInfo);
                let responseData = parsePKIoverFIDOResponse2(newCredentialInfo, CMD_TokenInfo);
                document.getElementById('label_token_fw').innerText = "FW version: " + responseData.FW;
                document.getElementById('label_token_sw').innerText = "SW version: " + responseData.SW;
                document.getElementById('label_pin_retries').innerText = "PIN retryies: " + responseData.PINRetries;
                document.getElementById('label_credentials').innerText = "Credentials: " + responseData.NumOfCredential;
                document.getElementById('label_serial_number').innerText = "Serial number: " +responseData.SN;
                document.getElementById('label_random_number').innerText = "Random number: " +responseData.RN;
                document.getElementById('label_ecPublic_key').innerText = "EC public point: " +responseData.ECPublic;

                console.log('Response : \n', responseData);

            }).catch((error) => {
                alert(error)
                console.log('FAIL', error)
            });
        });






        document.getElementById('btn_import_certificate2').addEventListener('submit', function (event) {
            event.preventDefault();


            let keyHandle = document.getElementById('target_key_handle').textContent;

            let keyId = document.getElementById('target_key_id').value;
            if (keyId.value = "") {
                alert("The KEY_ID cannot empty.");
                return;
            }
            console.log('key_handle', keyHandle);
            console.log('key_id', keyId);
            var keyHandleBuf = hexStringToArrayBuffer(keyHandle);
            let hexCert = Uint8Array.from(window.atob(testBigCertificate), c => c.charCodeAt(0));
            console.log('hexCert', hexCert);

            ImportCertificate2(keyHandleBuf, keyId, hexCert).then((responseData) => {
                console.log('SUCCESS', responseData);

                showSignMessage(responseData);
            });
        })
    </script>

</body>

</html>